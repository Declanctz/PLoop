# System.Web

`System.Web`是**PLoop**提供的独立的类库，需要单独`require "PLoop.System.Web"`来加载，它提供了和平台无关的Web框架。系统目前只支持UTF-8编码。具体实现需要针对平台来提供。

目前的实现有: 对应[Openresty][]服务器的[NgxLua][]，例子可以参考[PLoop.Browser][]，用于通过反射机制展示**PLoop**的类库。


## 目录

* [测试环境](#测试环境)
* [Web APP - System.Web.Application](#systemwebapplication)
	* [Web App的初始化](#web-app的初始化)
	* [nginx.conf配置](#nginx_conf配置)
	* [init.lua初始化](#init_lua初始化)
	* [我们的第一个Web App](#我们的第一个Web-App)
	* [`System.Web.__Json__`](#systemweb__json__)
	* [`System.Web.__Text__`](#systemweb__text__)
	* [`System.Web.__Redirect__`](#systemweb__redirect__)
	* [`System.Web.__View__`](#systemweb__view__)
* [常量](#常量)
* [编码和解码](#encode--decode)
* [上下文 - System.Web.HttpContext](#systemwebhttpcontext)
* [请求 - System.Web.HttpRequest](#systemwebhttprequest)
* [响应 - System.Web.HttpResponse](#systemwebhttpresponse)
* [Cookie管理 - System.Web.HttpCookie & System.Web.HttpCookies](#systemwebhttpcookie--systemwebhttpcookies)
* [会话 - System.Web.HttpSession](#systemwebsession)
	* [System.Web.ISessionIDManager](#systemwebisessionidmanager)
		* [The implementation of ISessionIDManager](#the-implementation-of-isessionidmanager)
			* [System.Web.GuidSessionIDManager](#systemwebguidsessionidmanager)
			* [NgxLua.JWTSessionIDManager](#ngxluajwtsessionidmanager)
	* [System.Web.ISessionStorageProvider](#systemwebisessionstorageprovider)
		* [ The implementation of ISessionStorageProvider](#the-implementation-of-isessionstorageprovider)
			* [System.Web.TableSessionStorageProvider](#systemwebtablesessionstorageprovider)
			* [NgxLua.ShareSessionStorageProvider](#ngxluasharesessionstorageprovider)
			* [NgxLua.RedisSessionStorageProvider](#ngxluaredissessionstorageprovider)
			* [NgxLua.JWTSessionStorageProvider](#ngxluajwtsessionstorageprovider)
* [路由 - System.Web.Route](#systemwebroute)
* [页面渲染](#page-rendering)
	* [Lua Server Page (.lsp)](#lua-server-page-lsp)
	* [Master Page (.master)](#master-page-master)
	* [Super web part](#super-web-part)
	* [Mix HTML with lua](#mix-html-with-lua)
		* [Block](#block)
		* [Inline](#inline)
		* [Full-line](#full-line)
		* [Mixed Method](#mixed-method)
	* [Helper Page (.helper)](#helper-page-helper)
	* [Embed Page (.embed)](#embed-page-embed)
	* [Inner Request Page](#inner-request-page)
	* [Lua Code file (.lua)](#lua-code-file-lua)
* [MVC框架 - System.Web.MVC](#systemwebmvc)
	* [System.Web.Controller](#systemwebcontroller)
* [表单验证](#form-validation)
* [用户认证](#user-authentication)
	* [Login validation](#login-validation)
	* [Authority Checking](#authority-checking)
* [上下文处理器](#context-handler)
* [错误处理](#error-handler)
* [相对路径和绝对路径](#relative-path--absolute-path)
* [配置](#systemwebconfig)
* [视图的配置](#configuration-for-templates)
* [自定义渲染引擎](#custom-render-engine)


## 测试环境

**PLoop**提供的Web框架是平台无关的，但为了更容易展现框架功能，我们选择[Openresty][]作为测试平台，目前只有[NgxLua][]针对[Openresty][]提供了**PLoop** Web框架的实现。如果期望在特定服务器上实现，可以参考[NgxLua][]，实际并不复杂。

测试环境采用的软件环境是(CentOS7 + Mysql 8 + Redis + Openresty)：

1. CentOS 7，请到http://isoredirect.centos.org/centos/7/isos/x86_64/，下载，作为测试环境，推荐使用[Oracle VM VirtualBox](https://www.virtualbox.org/)创建虚拟机，进行最小安装即可。

	如果采用虚拟机的话，配置时，网卡需要开启两个，一个是NAT网络，用于访问外网，另一个是Host-Only网络，这样主机可以直接通过IP访问虚拟机内开启的Web服务器。

	首次进入系统后，最好检查下/etc/sysconfig/network-scripts/ifcfg-enp0s8文件，可以使用vi编辑，确保`ONBOOT=yes`，开机加载。最好固定IP地址(IPADDR)，方便主机访问。

	**为了简单起见，下述操作都使用root账号进行，权限管理和优化都不会涉及**。


2. 服务器采用[Openresty][]，安装可以参考[Openresty的安装](https://openresty.org/cn/installation.html)，也可以直接尝试下面的操作：

	```shell
	yum install yum-utils
	yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo
	yum install openresty
	yum install openresty-resty
	```

	正常安装后，将路径添加到PATH，也可以写入~/.bashrc or ~/.bash_profile文件，确保开机加载

	```shell
	export PATH=/usr/local/openresty/bin:/usr/local/openresty/nginx/sbin:$PATH
	```

	测试下面的命令，如果能正确输出，说明安装正常，路径配置也正常了。

	```shell
	resty -e 'print("hello, world")'
	```

	新装的系统可能没开放80端口，需要先开启

	```shell
	firewall-cmd --zone=public --add-port=80/tcp --permanent
	```

3. 数据库采用Mysql 8.0，从[Mysql官网](https://dev.mysql.com/downloads/repo/yum/)可以查询最新的对应CentOS 7的版本，也可以采用下面的操作：

	安装Mysql 8.0，并设置开机启动

	```shell
	yum install wget
	cd /tmp

	wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm
	md5sum mysql80-community-release-el7-3.noarch.rpm
	rpm -ivh mysql80-community-release-el7-3.noarch.rpm
	yum install mysql-server -y
	systemctl start mysqld
	systemctl status mysqld
	```

	查看root@localhost的临时密码

	```shell
	grep 'temporary password' /var/log/mysqld.log

	mysql -u root -p
	```

	获取的临时密码等候就可以修改root密码，添加实际用户，这里简单创建一个具有所有权限的admin:

	```sql
	ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';
	CREATE USER 'admin'@'%' IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY '管理员密码';
	GRANT ALL PRIVILEGES ON * . * TO 'admin'@'%';
	FLUSH PRIVILEGES;
	```

	之后创建一个新的`PLoop`数据库，用于测试。

	```sql
	CREATE DATABASE PLoop;
	EXIT
	```

	暂时我们不创建数据库，稍后在MVC模块演示如何通过类型反射读取Model，自动生成数据库表结构。

4. 缓存数据库使用[Redis](https://github.com/antirez/redis)，可以在网站中拿去最新的版本，下面安装以5.0.6版为准：

	```shell
	cd /usr/local
	mkdir redis
	cd redis

	wget https://github.com/antirez/redis/archive/5.0.6.tar.gz
	tar -zxvf 5.0.6.tar.gz

	yum install gcc
	cd redis-5.0.6

	make
	cd src
	make install
	```

	安装后需要配置开机启动

	```shell
	cdd /etc
	mkdir redis
	cp /usr/local/redis/redis-5.0.6/utils/redis_init_script /etc/init.d/redisd
	cp /usr/local/redis/redis-5.0.6/redis.conf /etc/redis/6379.conf
	vi /etc/redis/6379.conf
	```

	最后一行是编辑6379.conf文件，找到里面的`daemonize=no`，需要修改为yes，然后保存退出。

	启动redis服务:

	```shell
	service redisd start
	```

	那么默认我们的Redis服务器运本地127.0.0.1的6379端口。

5. 针对使用[Oracle VM VirtualBox](https://www.virtualbox.org/)的用户，可以通过共享文件夹的形式，在Windows系统中编写代码，CentOS 7共享该目录，可以比较直接的运行整个网站，在开启Debug模式时，Windows上编辑代码文件，变更也会即时反映在CentOS上运行的网站上。

	首先需要选择安装的虚拟机，点击设置-共享文件夹，然后添加一个本地目录作为共享目录，分配名称为www（可自行修改），选择自动挂载。确定即可。

	然后，启动虚拟机，在虚拟机的界面，选择设备-安装增强功能，这样VBox会挂载一个iso，等待安装。

	准备工作

	```shell
	yum update
	yum install gcc kernel-devel make

	reboot
	```

	安装VBox增强功能。

	```shell
	mkdir /cdrom
	mount /dev/cdrom /cdrom

	/cdrom/VBoxLinuxAdditions.run
	```

	加载共享目录到 ~/www，为了方便，创建一个start.sh命令文件用于启动nginx，创建一个reload.sh命令文件用于重启nginx

	```shell
	cd ~
	mkdir www

	cat > start.sh <<EOF
	mount -t vboxsf www ~/www/
	cd www
	nginx -p `pwd`/www -c conf/nginx.conf
	EOF

	cat > reload.sh <<EOF
	cd www
	nginx -p `pwd`/www -s stop
	nginx -p `pwd`/www -c conf/nginx.conf
	EOF

	chmod +x start.sh
	chmod +x reload.sh
	```

	之后，程序部署到共享目录后，通过

	```shell
	cd ~
	./start.sh
	```

	启动网站，通过

	```shell
	cd ~
	./reload.sh
	```

	来重启网站，到此我们测试环境的准备工作就完成了。**之后所有提及的文件路径，都以这个共享文件夹为根路径**。


## Web App - System.Web.Application

### Web App的初始化

一个Web App(`System.Web.Application`类的对象)是一个单独的web服务，一个`nginx`服务可以运行多个Web App，每个App会具有自己独立的配置，路由，控制器等等。首先我们构建一个Web App然后在我们的测试环境中启动它:

简单起见，以下初始化操作在CentOS中完成，分别是拷贝默认的nginx配置以及下载**PLoop**及**NgxLua**两个库:

```shell
cd ~/www/
mkdir conf
cp /usr/local/openresty/nginx/conf/* ~/www/conf

yum install git -y

git clone https://github.com/kurapica/PLoop
git clone https://github.com/kurapica/NgxLua
```

### nginx.conf配置

之后打开/conf/nginx.conf文件（以后的文件编辑操作可以在windows上完成，或者任意你习惯的编辑方式），将内容替换为:

```conf
user root;

pid logs/nginx.pid;

events {
	worker_connections  1024;
}

http {
	include mime.types;

	lua_shared_dict plbr_session_storage 10m;
	lua_shared_dict ngxlua_file_lock 100k;

	lua_package_path "${prefix}?.lua;${prefix}?/init.lua;/usr/local/openresty/lualib/?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua";

	init_by_lua_file ./conf/init.lua;

	server{
		listen       80;
		server_name  localhost;

		location / {
			root html;

			# MIME type determined by default_type:
			default_type 'text/html';

			content_by_lua ' PLBR.HttpContext():Process() ';
		}
	}
}
```

user选择root是简单的避免权限问题，实际项目请自行管理权限设置。上面定义了两个共享表，`plbr_session_storage`用于保存用户会话状态，`ngxlua_file_lock`用于提供全局锁的机制，例如加载代码，或者网页模板时，需要加锁，避免同时多个类生成，产生冲突。但一般加载后，除非文件变更需要重载，是不需要再使用全局锁的，所有不会影响服务器的高并发。具体使用在多线程环节介绍。

`lua_package_path`制定了Lua加载库的路径，`${prefix}`是网站的根路径，即 `~/www/`，所以，保存在它下面的**PLoop**和**NgxLua**都可以被正常加载，后面的是[Openresty][]随附的Lua库。基本是常用库。

`init_by_lua_file`指明了启动nginx时，初始化用的Lua文件，通常我们在这个文件中，加载**PLoop**和**NgxLua**库，然后加载各个Web App。

这里我们只加载一个用于浏览**PLoop**提供的类库的Web App，所以，只定义一个server，其中`content_by_lua`是我们处理的入口，其中`PLBR`是我们将要申明的命名空间，通常一个Web APP应该具有一个独立的命名空间，`PLBR.HttpContext`是一个上下文对象，为了在多OS线程平台上使用Lua，我们通常需要一个上下文对象来隔离处理，由上下文对象启动Http请求的处理，这个过程中创建的所有对象都可以在上下文对象中读写值，因为单个系统线程中的Lua操作实际是单线程，所以，这些对象可以没有冲突的通过上下文对象共享值。稍后会详细介绍上下文对象。


### init.lua初始化

创建`/conf/init.lua`文件，这里我们将加载网站的基础代码部分，主要是加载类库和加载Web App，但Web App具体实现会在稍后再定义：

```lua
PLOOP_PLATFORM_SETTINGS = { CORE_LOG_LEVEL = 3, MULTI_OS_THREAD = true, TYPE_VALIDATION_DISABLED = false }

-- NgxLua会加载PLoop
require "NgxLua"

-- 全局配置，不限定哪个Web App
PLoop(function(_ENV)
	-----------------------------------------------------------------------
	--                            全局Web配置                            --
	-----------------------------------------------------------------------
	Web.Config                  = {
		Debug                   = true,
		LogLevel                = System.Logger.LogLevel.Debug,
	}

	-----------------------------------------------------------------------
	--                            线程锁管理器                            --
	-----------------------------------------------------------------------
	NgxLua.LockManager("ngxlua_file_lock")
end)

-- 加载Web App，可以按顺序加载多个
require "plbr"
```

注意，这里通过`PLOOP_PLATFORM_SETTINGS`将`MULTI_OS_THREAD`置为true，Web服务器都是多系统线程的，为了避免冲突，必须开启这个选项。`Web.Config`是Web框架的全局配置，不涉及单个Web App，这里的`Debug`设置为true，那么当资源文件类似网站模板文件修改后，再次访问时，系统会重新加载，这可以比较即时的看到修改结果。但因为需要检查文件修改时间，并且因为资源文件间存在依赖关系（子类，超类），检查文件的数量可能会比较多，仅仅适用于开发阶段，实施时请务必修改为false。

`NgxLua.LockMananger`是使用[Openresty][]提供的共享表来实现线程锁，它没有太多的可以配置的属性，基本保持这样的申明处理即可。这里使用的`ngxlua_file_lock`是在`nginx.conf`中申明的。


### 我们的第一个Web App

创建`/plbr/`目录，这个目录将是我们实际的项目代码目录，首先创建`/plbr/init.lua`文件，这个文件将保存我们在初始化时需要加载的所有文件。这些文件通常是路由，模型，常用类型等的定义。这些必须在初始化时加载，并且系统无法在运行过程中重新加载（使用上面的`./reload.sh`来重新初始化整个网站）。

在这个文件中，我们将初始化我们的Web App，并加载一个路由文件。

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	-- 定义PLBR.HttpContext，它继承了NgxLua.HttpContext
	-- 唯一功能是构造时，绑定自己的Application为当前的Web App
	-- 注意，Application继承了`System.Module`，所以可以作为
	-- 环境使用，这里的 _ENV 就是 Application "PLBR"
	--
	-- 请重点注意，上下文仅仅是作为请求执行的容器，类似路由，
	-- 控制器等等实际处理都是归属于特定的Web App的，所以，
	-- 每个Http上下文对象都需要关联一个Web App，才能进行实际处理
	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}
end)

-- 保存PLBR到_G
import "PLBR"

-- 加载路由文件
require "plbr.router"
```

`Application`是由Web框架保存到`_G`的类，它继承了`System.Module`，所以可以作为环境使用，也提供了树状的代码管理机制（虽然很少需要这么使用）。在它里面，我们申明了`PLBR`命名空间，注意和Web App区分开来。之后定义了独属于这个Web App的Http上下文类，实际就是将它的对象和这个Web App进行绑定。

之后在`nginx.conf`文件的`content_by_lua`中，我们就是构建了这个上下文类的对象，然后调用`Process`方法启动请求的执行处理。这里的部分实际并不涉及具体的业务逻辑，因为根据请求url的不同，我们需要进行的处理都不相同，那么首先我们需要能根据url对请求进行分发，第一步，我们需要一个路由文件进行管理。

```lua
-- /plbr/router.lua
Application "PLBR" (function(_ENV)
	-- 所有属于PLBR这个Web App的配置，资源都需要定义在这个Web App环境中

	__Route__("/")
	__Text__() function hello(self, context)
		return "Hello world"
	end
end)
```

保存后，启动服务器(初次需要创建一个logs目录)

```shell
cd ~/www/
mkdir logs
cd ~
./start.sh
```

如果启动过，用`./reload.sh`。

然后可以打开浏览器，输入虚拟机地址(ip addr，VBOX的话，一般是192.168.56.xx)或你的服务器地址直接访问，或者CentOS中使用

```shell
curl http://localhost
```

就可以看到输出结果是`Hello world`。这样，我们的测试环境就正式可以使用了。可以看到，虽然之前做了很多铺垫，但实际业务逻辑相当简单。路由，输出方式和保存有业务逻辑的函数绑定，我们可以使用路由完成所有的Web API创建的工作，不过这只是基础部分，通常并不会将主要业务放在路由中直接处理，而是使用MVC中控制器来处理业务，稍后会看到详细的介绍。

**稍等继续更新**




An **Application** is a standalone web service, a server like *nginx* can host several applications. The application will have its own configurations, routers, controllers and etc.

Here is a simple web application:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"  -- The System.Web will load the PLoop

app = Application "TestWebApp" (function(_ENV)
	__Route__("/jsonhandler", HttpMethod.GET)
	__Json__() function JsonHandler(context)
		return {
			Data = {
				{ Name = "Ann", Age =  12},
				{ Name = "King", Age =  32},
				{ Name = "July", Age =  22},
				{ Name = "Sam", Age =  30},
			}
		}
	end
end)
```

Before loading the **PLoop**, we must set the **MULTI_OS_THREAD** to true, since web service like the [Openresty][] is a multi-os thread platform.

The **Application** is inheirted from the **System.Module**, so normally it works like the module system. The **app** variable is given out, so it can be  used by the web server to handle web requests.

In the app, we have a *JsonHandler* function who has two attribute:

* `__Route__("/jsonhandler", HttpMethod.GET)` register the function as the handler for route `/jsonhandler` when the http method is "GET"
* `__Json__` means the return value of the function will be serialized to JSON format and send to the response.

Now we can simulate the process of the http request and get a result from the web app:

```lua
-- Copy the previous example code here

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	-- Each http request should be processed in a http context
	-- we must pass a web application to it, so the request
	-- will be handled by the handlers registered in the app
	local ctx = HttpContext(app)

	--=====================================================
	-- the below codes are normally done by the implementation for the
	-- target platform, so you can ignore this part
	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.CombinePath(IO.Path.GetCurrentPath(), "root")
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	--=====================================================

	-- Start the process of http request, any web service use PLoop
	-- should pass the request into PLoop with this code
	ctx:Process()

	--=====================================================
	-- The output part, you also should ignore this part
	writer:Close()
	print(writer.Result)
	--=====================================================
end

-- {"Data":[{"Name":"Ann","Age":12},{"Name":"King","Age":32},{"Name":"July","Age":22},{"Name":"Sam","Age":30}]}
main("/jsonhandler")
```

In the main function, we create the **HttpContext** of the web app and then we create the **HttpRequest** and **HttpResponse** of the context.

After those objects created, we can call the **Process** method of the context, the context will check the web app's router system to find a match handler to url, and then use the handler to process the request and send the result to the response.

In a real project, the request, response is generated by the system, you don't need to manually do it.

Any routes without regex patterns are static routes, the system only need O(1) to choose them.


### `System.Web.__Json__`

As we can see the `__Json__` attribute will wrap the function and use it as the route handler, the return value of the function will be serialized to JSON format data.

The funciton will receive the http context object, so we can get the query string or form from the request:

```lua
__Route__("/jsonhandler", HttpMethod.GET)
__Json__() function JsonHandler(context)
	return {
		User = { Name = context.Request.QueryString.name }
	}
end

-- {"User":{"Name":"ann"}}
main("/jsonhandler", {name = "ann"})
```

The other codes are skipped, you can test it by your own.


### `System.Web.__Text__`

The `__Text__` attribute is used to generate the text as response, it can only return a text or be used as an iterator to generate the texts:

```lua
__Route__("/text", HttpMethod.GET)
__Text__() function TextHandler(context)
	return "Hello, this is single text test"
end

__Route__("/multitext", HttpMethod.GET)
__Text__(true) __Iterator__()
function MultiText(context)
	coroutine.yield("This is part of the result\n")
	coroutine.yield("This is another part of the result\n")
end

-- Hello, this is single text test
main("/text")

-- This is part of the result
-- This is another part of the result
main("/multitext")
```

The `__Text__(true)` means the function is async, should be used as an iterator.


### `System.Web.__Redirect__`

The `__Redirect__` attribute is used to redirect the client to a new url, the function should return the new url.

```lua
__Route__("/redirect")
__Redirect__() function TextHandler(context)
	return context.Request.QueryString.path or "/404"
end
```


### `System.Web.__View__`

The `__View__` attribute is used to bind a view template or template file path to the target function, so the return value of the function will be used to generate the output response:

```lua
__Route__("/index")
__View__ "index.view" [[
	<html>
		<head>
			<title>@self.title</title>
		</head>
		<body>
			<p>@self.welcome</p>
		</body>
	</html>
]]
function index(context)
	local name = context.Request.QueryString.name

	return { title = "Hi " .. name, welcome = "Welcome here, " .. name }
end


-- <html>
--    <head>
--        <title>Hi Ann</title>
--    </head>
--    <body>
--        <p>Welcome here, Ann</p>
--    </body>
-- </html>
main("/index", { name = "Ann" })
```

The `index.view` has two usage, the `index` will be used to generate as the view class name, and the `.view` will notify the system to use the registered **ResourceLoader** to load the text to a view class. Then the view class would be used to generate the output.

For the snippet `@self.title` in the template, the self is a view class's object, it'd use the return value from the function as the object's init-table.

If we don't specific the view template in the `__View__` attribtue, the function should return the view file path and the data like :

```lua
__Route__("/index")
__View__() function index(context)
	local ver = tonumber(context.Request.QueryString.ver)

	if ver == 1 then
		return "/view/index_v1.view", { data = context.Request.QueryString }
	else
		return "/view/index_last.view", { data = context.Request.QueryString }
	end
end
```

Normally the view is used in the MVC framework, we'll see more details about the template system at later.


## 常量

Here is the list of **System.Web** enums.

```lua
__Flags__() __Sealed__() __Default__"GET"
enum "HttpMethod" {
	ALL                 = 0,
	"OPTIONS",
	"GET",
	"HEAD",
	"POST",
	"PUT",
	"DELETE",
	"TRACE",
	"CONNECT",
}

--- the http status
__Sealed__() __Default__ "OK"
enum "HTTP_STATUS" {
	CONTINUE            = 100,  --The request can be continued.
	SWITCH_PROTOCOLS    = 101,  --The server has switched protocols in an upgrade header.
	OK                  = 200,  --The request completed successfully.
	CREATED             = 201,  --The request has been fulfilled and resulted in the creation of a new resource.
	ACCEPTED            = 202,  --The request has been accepted for processing, but the processing has not been completed.
	PARTIAL             = 203,  --The returned meta information in the entity-header is not the definitive set available from the originating server.
	NO_CONTENT          = 204,  --The server has fulfilled the request, but there is no new information to send back.
	RESET_CONTENT       = 205,  --The request has been completed, and the client program should reset the document view that caused the request to be sent to allow the user to easily initiate another input action.
	PARTIAL_CONTENT     = 206,  --The server has fulfilled the partial GET request for the resource.
	WEBDAV_MULTI_STATUS = 207,  --This indicates multiple status codes for a single response. The response body contains Extensible Markup Language (XML) that describes the status codes. For more information, see HTTP Extensions for Distributed Authoring.
	AMBIGUOUS           = 300,  --The requested resource is available at one or more locations.
	MOVED               = 301,  --The requested resource has been assigned to a new permanent Uniform Resource Identifier (URI), and any future references to this resource should be done using one of the returned URIs.
	REDIRECT            = 302,  --The requested resource resides temporarily under a different URI.
	REDIRECT_METHOD     = 303,  --The response to the request can be found under a different URI and should be retrieved using a GET HTTP verb on that resource.
	NOT_MODIFIED        = 304,  --The requested resource has not been modified.
	USE_PROXY           = 305,  --The requested resource must be accessed through the proxy given by the location field.
	REDIRECT_KEEP_VERB  = 307,  --The redirected request keeps the same HTTP verb. HTTP/1.1 behavior.
	BAD_REQUEST         = 400,  --The request could not be processed by the server due to invalid syntax.
	DENIED              = 401,  --The requested resource requires user authentication.
	PAYMENT_REQ         = 402,  --Not implemented in the HTTP protocol.
	FORBIDDEN           = 403,  --The server understood the request, but cannot fulfill it.
	NOT_FOUND           = 404,  --The server has not found anything that matches the requested URI.
	BAD_METHOD          = 405,  --The HTTP verb used is not allowed.
	NONE_ACCEPTABLE     = 406,  --No responses acceptable to the client were found.
	PROXY_AUTH_REQ      = 407,  --Proxy authentication required.
	REQUEST_TIMEOUT     = 408,  --The server timed out waiting for the request.
	CONFLICT            = 409,  --The request could not be completed due to a conflict with the current state of the resource. The user should resubmit with more information.
	GONE                = 410,  --The requested resource is no longer available at the server, and no forwarding address is known.
	LENGTH_REQUIRED     = 411,  --The server cannot accept the request without a defined content length.
	PRECOND_FAILED      = 412,  --The precondition given in one or more of the request header fields evaluated to false when it was tested on the server.
	REQUEST_TOO_LARGE   = 413,  --The server cannot process the request because the request entity is larger than the server is able to process.
	URI_TOO_LONG        = 414,  --The server cannot service the request because the request URI is longer than the server can interpret.
	UNSUPPORTED_MEDIA   = 415,  --The server cannot service the request because the entity of the request is in a format not supported by the requested resource for the requested method.
	RETRY_WITH          = 449,  --The request should be retried after doing the appropriate action.
	SERVER_ERROR        = 500,  --The server encountered an unexpected condition that prevented it from fulfilling the request.
	NOT_SUPPORTED       = 501,  --The server does not support the functionality required to fulfill the request.
	BAD_GATEWAY         = 502,  --The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.
	SERVICE_UNAVAIL     = 503,  --The service is temporarily overloaded.
	GATEWAY_TIMEOUT     = 504,  --The request was timed out waiting for a gateway.
	VERSION_NOT_SUP     = 505,  --The server does not support the HTTP protocol version that was used in the request message.
}
```


## 编码和解码

There are four useful encode/decode method defined in the **System.Web**:

Method             |Arguments                                                            |Description
:------------------|:--------------------------------------------------------------------|:------------------------------
HtmlEncode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |Encodes a string to be displayed in a browser
HtmlDecode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |Decodes a string that has been encoded to eliminate invalid HTML characters
UrlEncode          |text:String                                                          |Encodes a URL string
UrlDecode          |text:String                                                          |Converts a URL string into a decoded string

```lua
require "PLoop.System.Web"

PLoop(function(_ENV)
	local str = HtmlEncode("<test>")
	print(str)               -- &lt;test&gt;
	print(HtmlDecode(str))   -- <test>

	str       = UrlEncode("/test?x=123")
	print(str)               -- %2Ftest%3Fx%3D123
	print(UrlDecode(str))    -- /test?x=123
end)
```


## 上下文 - System.Web.HttpContext

When a http request reached the system, a http context object must be created to process the request. A context object will provide several features:

Abstract Property           |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Request                     |HttpRequest                       |The object contains all request informations
Response                    |HttpResponse                      |The object used to generate the response
SessionType                 |- HttpSession                     |The session type that would be used to generate the session object
-----------------------------------------------------------------------------------------


Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Application                 |Application                       |The web application of the context, it contains all features like routers, controllers and etc, it must be assgined before process the request
ProcessPhase                |IHttpContextHandler.ProcessPhase  |The current process phase, explain later
Session                     |HttpSession                       |Gets the session object from the current context
IsInnerRequest              |Boolean                           |Whether this is an inner request
-----------------------------------------------------------------------------------------

Method                      |Arguments                                                   |Description
:---------------------------|:-----------------------------------------------------------|:-------------------------
Process                     |                                                            |Process the http request
ProcessInnerRequest         |url: String, params: Table/nil, HttpMethod/nil              |Process an inner request, like retrieve json result from other url as data

Although the class is not abstract, but features like the abstract properties must be implemented by the real http context class that created based on the platform, you can find one implementation in the [NgxLua][].

The **ProcessInnerRequest** will return the inner request's status code plus the redirected path or the json data(the text result will be write to the client directly).


## 请求 - System.Web.HttpRequest

The http request contains all informations from the client, although the class is not abstract, but features like the abstract properties must be implemented by the real http request class that created based on the platform, you can find one implementation in the [NgxLua][].

Abstract Property           |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
ContentLength               |                                  |Specifies the length, in bytes, of content sent by the client
ContentType                 |                                  |Gets the MIME content type of the incoming request
Cookies                     |                                  |Gets a collection of cookies sent by the client
Form                        |                                  |Gets a collection of form variables
HttpMethod                  |                                  |Gets the HTTP data transfer method (such as GET, POST, or HEAD) used by the client
IsSecureConnection          |                                  |Gets a value indicating whether the HTTP connection uses secure sockets (that is, HTTPS)
QueryString                 |                                  |Gets the collection of HTTP query string variables
RawUrl                      |                                  |Gets the raw URL of the current request
Root                        |                                  |Get the root path of the query document
Url                         |                                  |Gets information about the URL of the current request
------------------------------------------------------------------------------------------

Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |The http context of the request
Handled                     |Boolean                           |Whether the request is handled


## 响应 - System.Web.HttpResponse

The http response will send the response to the client, although the class is not abstract, but features like the abstract properties must be implemented by the real http response class that created based on the platform, you can find one implementation in the [NgxLua][].

Abstract Property           |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
ContentType                 |                                  |Gets or sets the HTTP MIME type of the output stream.
RedirectLocation            |                                  |Gets or sets the value of the Http Location header.
RequestRedirected           |                                  |Whether the request is been redirected.
Write                       |                                  |Gets or sets the response write function or callable writer.
StatusCode                  |                                  |Gets or sets the HTTP status code of the output returned to the client.
Cookies                     |System.Web.HttpCookies            |Gets a collection of cookies sent to the client.
------------------------------------------------------------------------------------------


Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |The http context of the response
------------------------------------------------------------------------------------------


Abstract Method             |Arguments                         |Description
:---------------------------|:---------------------------------|:-------------------------
SendHeaders                 |                                  |Send the response headers
Close                       |                                  |Finish the response, used to close resources such like output wirter
ServerRedirect              |                                  |Server redirect the client to a new URL
------------------------------------------------------------------------------------------


Method                      |Arguments                                                                |Description
:---------------------------|:------------------------------------------------------------------------|:-------------------------
Redirect                    |url: String, code: HTTP_STATUS/HTTP_STATUS.REDIRECT, raw: Boolean/false  |Redirects the client to a new URL, the application may be used for the secondary domain, so it'll have a root path like '/mydomain/', if not raw, the url will be converted to '/mydomain/' + url


## Cookie管理 - System.Web.HttpCookie & System.Web.HttpCookies

The request's **Cookies** should be a name-value collections (just a table) that contains the cookie pairs send by the client's browser. So it can be used like :

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function test(context)
	return {
		User = { Name = context.Request.Cookies["name"] }
	}
end
```

Save cookies to the response is a little different, The **HttpResponse.Cookies** is generated from **System.Web.HttpCookies** and it's a collection of **System.Web.HttpCookie**. Using a cookie name in it would create or get the created cookie, so you can use it like :

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function writecookie(context)
	context.Response.Cookies["ID"].Value = "TestUser1234"
	return {}
end
```

The **HttpCookie** contains several properties could be set:

Property                    |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Domain                      |String                            |Gets or sets the domain to associate the cookie with.
Expires                     |Date                              |Gets or sets the expiration date and time for the cookie.
MaxAge                      |Number                            |Gets or sets the max age for the cookie.
HasKeys                     |Boolean                           |Gets a value indicating whether a cookie has subkeys.
HttpOnly                    |Boolean                           |Gets or sets a value that specifies whether a cookie is accessible by client-side script.
Name                        |String                            |Gets or sets the name of a cookie.
Path                        |String                            |Gets or sets the virtual path to transmit with the current cookie.
Secure                      |Boolean                           |Gets or sets a value indicating whether to transmit the cookie using Secure Sockets Layer (SSL)--that is, over HTTPS only.
Value                       |String                            |Gets or sets an individual cookie value.
Values                      |Table                             |Gets a collection of key/value pairs that are contained within a single cookie object.


You can set the expires date like :

```lua
context.Response.Cookies["ID"].Expires = System.Date.Now:AddDays(30)
```

Also sub-items can be added like :

```lua
context.Response.Cookies["ID"].Values["Age"] = 33
context.Response.Cookies["ID"].Values["Gender"] = "male"
```

The **Cookies** in the **Response** is a lazy property, so the object will only be created if you need it, so for other properties in the web system.


## 会话 - System.Web.HttpSession

The http session is used to track the unique client, it may use several ways to identify the client, for now, the system and [NgxLua][] only provide the implementation based on the cookies.

When a http request send to the server and any logic access the **Session** from the http context for the first time, a session object will be created,  it's a lazy operation when you need it.

Before we dicuss how to generate the session object, we have to see the details of the session object:

Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |The http context of the session
Items                       |String                            |An indexer property used to sets or gets values, the values should be serializable
SessionID                   |String                            |Gets the unique identifier for the session
Timeout                     |String                            |Gets or sets the date time, allowed the next request access the session
TimeoutChanged              |String                            |Whether the time out is changed
Canceled                    |String                            |Whether the current session is canceled
IsNewSession                |String                            |Whether the session was created with the current request or its timeout is changed
ItemsChanged                |String                            |Whether the session items changed, if changed the system will save the session items into cache

We can save or get values from the **Items** :

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function writecookie(context)
	context.Session.Items.user = "TestUser1234"
	return {}
end
```

In the business code, we only need use the **Items** property. The other properties are used by the frameworks.

The **Items** can only check one level for item changing, so for codes like

```lua
context.Session.Items.UserList[1003] = { name = "king" }
```

The system can't detect the change, you'd better create a copy of the **UserList** and then use the clone to replace it:

```
local userList = System.Toolset.clone(context.Session.Items.UserList) or {}
userList[1003] = { name = "king" }
context.Session.Items.UserList = userList
```

The main problem about the **Session** is how we save the identify in the client, and how we save the session in the server.


### System.Web.ISessionIDManager

For each session object, the unique value is the **SessionID**, so the question is how we generate the **SessionID** and how we save it in the client, the **ISessionIDManager** is the interface to manage the session IDs.

Any implementation must provide those methods:

Abstract Method             |Arguments                                  |Description
:---------------------------|:------------------------------------------|:-------------------------
GetSessionID                |context: HttpContext                       |Gets the session identifier from the context of the current HTTP request.
CreateSessionID             |context: HttpContext                       |Creates a unique session identifier.
RemoveSessionID             |context: HttpContext                       |Deletes the session identifier in the current HTTP response.
SaveSessionID               |context: HttpContext, session: HttpSession |Saves a newly created session identifier to the HTTP response.
ValidateSessionID           |id: String                                 |Validate the session id

You can find an implementation **System.Web.GuidSessionIDManager** in the **PLoop**, it use the cookie to save the session id, and would use **System.Guid** to generate the session id.

Here is an example to create it:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	-- Session ID Manager
	GuidSessionIDManager { CookieName = "TestWebSessionID", TimeoutMinutes = 1 * 24 * 3600, Application = _ENV }
end)
```

The id manager is a global context handler be used by all http context of the same application, so in the application, we only need to create it for one time.

For the example, we create an id manager who use the *TestWebSessionID* in the cookie, and the time out should be 1 day.

We specific the `_ENV` also the web app as the **Application** to the **GuidSessionIDManager**, so it's used by the application, if omit, it'd be used for all web apps in the same host, if we also use the same cache mechanism, we may share the sessions between those web apps.


#### The implementation of ISessionIDManager

There are two implementations of the **ISessionIDManager** defined in **PLoop** and **NgxLua**:


##### System.Web.GuidSessionIDManager

The manager is using **System.Guid** as the session id, and save the session id in the cookie, we can specific the cookie name by its "CookieName" property like the previous example.


##### NgxLua.JWTSessionIDManager

The manager is designed to use the JSON Web Token as the identify based on [resty.jwt](https://github.com/SkyLothar/lua-resty-jwt), since it's saved in the client, there is no real session id that generated for server to save. It also use the cookie to save the token.

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "NgxLua"

app = Application "TestWebApp" (function(_ENV)
	-- Session ID Manager
	-- The default value of HashAlgorithm is `HS256`
	-- The default value of SecretKey is a random value generated from System.Guid,
	-- if not specific, all token in clients will be invalid when we reload the web server
	NgxLua.JWTSessionIDManager{ CookieName = "TestWebJWT", TimeoutMinutes = 1 * 24 * 3600, SecretKey = "XXXXXXXX", HashAlgorithm = "HS256", Application = _ENV }
end)
```



### System.Web.ISessionStorageProvider

The session should be saved in the server or other data server like redis, so the next time the same user send a http request, we can use the saved values in the session, you must only save serializable values in the session.

The **ISessionStorageProvider** is the interface to manage the session storage, the implementation of it must provide those methods:

Abstract Method             |Arguments                                  |Description
:---------------------------|:------------------------------------------|:-------------------------
Contains                    |id: String                                 |Whether the session ID existed in the storage.
GetItems                    |id: String                                 |Get session item
RemoveItems                 |id: String                                 |Remove session item
SetItems                    |id: String, item: Table, timeout: Date/nil |Update the item with current session data
ResetItems                  |id: String, timeout: Date                  |Update the item's timeout
TrySetItems                 |id: String, item: Table, timeout: Date/nil |Try sets the item with an un-existed key, return true if success

In the **PLoop**, a **TableSessionStorageProvider** is provided, but since it's not thread-safe, it's only used for test. In the [NgxLua][], **ShareSessionStorageProvider** and **RedisSessionStorageProvider** is provided, the first would use the share table provided by the [Openresty][], it's simple and useful for small scale web service or development, the second use the redis server.

Here is the example to use them:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "NgxLua"

Application "TestWebApp" (function(_ENV)
	-- Storage
	-- NgxLua.ShareSessionStorageProvider("havc_session_storage", application)
	NgxLua.RedisSessionStorageProvider({ host = "127.0.0.1", port = 6379 }, application)
end)
```

The *havc_session_storage* is a share table defined in the *nginx.conf*, like the id manager, the storage provider is also a global context handler, we only need to create one for the application.


#### The implementation of ISessionStorageProvider

There are four implementations of the **ISessionStorageProvider** defined in the **PLoop** and **NgxLua**:


##### System.Web.TableSessionStorageProvider

This is a test session storage that use a table as the session item storage. It is not thread-safe, so only usable for simple test.

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

Application "TestWebApp" (function(_ENV)
	TableSessionStorageProvider(_ENV)
end)
```


##### NgxLua.ShareSessionStorageProvider

This is defined based on the share dict of the [Openresty][], it's used like

nginx.conf
```
http {
	lua_shared_dict test_session_storage 10m;
}
```

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "NgxLua"

Application "TestWebApp" (function(_ENV)
	ShareSessionStorageProvider("test_session_storage", _ENV)
end)
```


##### NgxLua.RedisSessionStorageProvider

This is defined based on the [resty.redis](https://github.com/openresty/lua-resty-redis), it's used like

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "NgxLua"

Application "TestWebApp" (function(_ENV)
	NgxLua.RedisSessionStorageProvider({ host = "127.0.0.1", port = 6379 }, _ENV)
end)
```


##### NgxLua.JWTSessionStorageProvider

This is designed for JSON Web Token based on [resty.jwt](https://github.com/SkyLothar/lua-resty-jwt), it'll save the session items in the client not the server, we should only save identify token like user id in it.

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "NgxLua"

Application "TestWebApp" (function(_ENV)
	NgxLua.JWTSessionIDManager{ CookieName = "TestWebJWT", TimeoutMinutes = 3600, Application = _ENV }
	NgxLua.JWTSessionStorageProvider{ Application = _ENV }

	__Route__("/login", HttpMethod.POST)
	__Form__{ userid = { type = Number, require = true } }
	function login(context, form, err)
		if err then
			context.Response.StatusCode = HTTP_STATUS.NOT_FOUND
			return
		end

		-- the user id will be saved in the JWT to the client
		context.Session.Items.user_id = form.userid
		context.Response:Redirect("/")
	end
end)
```


## 路由 - System.Web.Route

The **Route** system is a little complex, but luckly, we only need use the `__Route__` attribute to bind the url to their handlers, the previous examples has shown the static url handlers, ther have no patterns, the system will only use a hash table to save them, and can get the handler by one access.

But we can't make all features just by the static url handlers, and the disadvantage of the static routers are we need to restart the web if we modified them.

We still need dynamic routes and dynamic handlers.

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	__Route__ ".lsp"
	function LuaServerPage(context)
		return context.Request.Url
	end
end)
```

Sine there is no attribute like `__View__`, `__Json__` that describe the response of the request, the return value will be used as the absolute path to the resource file.

So for the url like `/home/index.lsp`, the file index.lsp in the /home dir will be used.

The `.lsp` let the system know which resouce loader should be used, and then the file will be converted to a class(or get the class if already created), an object will be generated from the class to handle the request.

Since those resource files can be reloaded by the resource system, we can modify them and see the changes without restart the web service, although the reload behavior must be turn off to reduce the cost when we publish the web app. We'll see how to change it in the configuration part.


## 页面渲染

### Lua Server Page (.lsp)

Normally we should use the MVC framework instead of the lua server page, but it's a good start for the page rendering.

To create a simple html page like:

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>PLoop.System.Web Test Page</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
	</head>
	<body>
		<p>
			This is the first PLoop.System.Web test page.
		</p>
	</body>
</html>
```

Just copy the content to a .lsp file (like index.lsp). The lsp file contains the html and lua code and will be converted to a page class, then it would be used to handle the http request and generate the response.

The **PLoop** only provided one special page render engine **System.Web.PageRenderEngine**, so all template files will follow the same rules. We'll see how to create another page render engine at the last.


### Master Page (.master)

When you need to apply the same layout for several lsp files, it's best to create a master page that incldue the most common parts.

A master page file is ended with ".master". We can create a "mymaster.master" with the content :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>@{title My web site}</title>
		@{jspart <!-- javascript placeholder -->}
	</head>
	<body>
		@{body}
	</body>
</html>
```

The render engine use *@* as the directive, it means an instruction here to be executed.

The `@{title My web site}` is used to declare a **web part** that would be replaced by child page classes, *title* is it's name, the rest are default text, if the web part is not defined in the child page, the default text would be used.

Then the *index.lsp* :

```HTML
@{ master = "mymaster.master" }

@title{
	PLoop.System.Web Test Page
}

@body{
	<p>
		This is the first PLoop.System.Web test page.
	</p>
}
```

There is a special rule for all template files(no matter if it use another custom page render engine), if the first line of the file contains a lua table, it would be parsed as the page's configuration.

In here the *master* means the page class's super class, the *index.lsp* can also be used as another lsp file's master page, so the web part can be declared in both master page and the lua server page. Since the *index.lsp* inherited the *mymaster.master*, the *index.lsp* only need to define the web parts.

To implement a web part, the `@name{` and `}` must be on each line's head, and the content must have an indent(tab or space) for each line, so the render engine will know the begin and the end of it.

Beware, you must keep using the same indent style for one files (only use tab or only use space, and keep the start and end part with same indents).

If the page don't provide a web part, it would be leave empty or use the web part's default value. So if it don't give the *title* part, the output content should be `<title>My web site</title>`.

The output result of *index.lsp* would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>PLoop.System.Web Test Page</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<p>
			This is the first PLoop.System.Web test page.
		</p>
	</body>
</html>
```

### Super web part

We can override the master page's web part, but we also may need to show the contents come from the master page, we could use `@{super:body}` to generate the *body* web part designed in its master pages(or other super pages):

```html
@{ master = "index.lsp" }


@body{
	@{super:body}
	<p>
		This is the a PLoop.System.Web test page.
	</p>
}
```


### Mix HTML with lua

To embed Lua into html, there are four ways within the default page render engine :

#### Block

Used to define pure lua functions, also can be used to define the page class's method and other features :

```lua
@{
	local function rollDice(num, max, add)
		local sum = add

		for i = 1, num do
			sum = sum + math.random(max)
		end

		return sum
	end
}
```

Define a block of lua code is like defining a web part without name, it would be pure lua code in the block, if the function is not defined as local, it would be a class-method of the page class. The function and any variables defined in it can be used by anywhere that below the block.


#### Inline

Used to print an expression value, if the expression is not clear, the expression should be enclosed in parentheses, if use `@\`, the value would be encoded (or in the page configuration, use `encode=true` to force encoding all inline expressions) :

```html
@body{
	<p>Roll a dice(5d6+3) : @rollDice(5, 6, 3) </p>
	<p>encode test : @\"<test/>" </p>
}
```
The output should be like

```html
	<p>Roll a dice(5d6+3) : 22</p>
	<p>encode test : &lt;test/&gt; </p>
```

Things like `@a`, `@b`, `@(a+b)`, `@rollDice(5, 6, 3)` are inline codes, an inline code should be an expression that return a value, the value would be converted to a string to be displayed.

For the `a + b` expression, `@a + b` would confuse the system, it will treate the `@a` is a inline code, and the `+ b` is normal text, you should use parentheses around it.

The system can realize complex expression like `@King.Parent:Greet( Person{ Name = "Ann" } )`, also can realize string word like `@'test'`, `@"test"` or `@[=[test]=]`.

The table data returned by the expression will be serialized to JSON format string, so you can use it directly in javascript section like

```html
<script type="text/javascript">
	var data = @List(10):Map("x=>x^2"):ToList();
</script>
```

The result would be

```html
<script type="text/javascript">
	var data = [1,4,9,16,25,36,49,64,81,100];
</script>
```


#### Full-line

Normally used to generate the control structure to control how the content would be generated, use '@>' to mark the full line is lua code, if the first word of the line is a keyword like 'local', 'if', 'for', you can only use '@' at the start of the line, and `@--` would be used for full line comments :

```html
@body{
	@ local a, b = math.random(100), math.random(100)
	<p>@a + @b = @(a+b)</p>

	<p>Roll a dice(5d6+3) : @rollDice(5, 6, 3) </p>

	<p>
	@ local hour = Date.Now.Hour
	@ if hour < 11 then
		Good morning
	@ elseif hour > 20 then
		Good night
	@ end
	</p>
}
```

The *body* web part will be converted to one function, so you can declare any local variables and use any structures like `if-then-end`, `while-do-end`, `for-end`.  The control structures must be full-line.

The result should be

```html
	<p>81 + 87 = 168</p>

	<p>Roll a dice(5d6+3) : 24 </p>

	<p>
		Good night
	</p>
```


#### Mixed Method

If we take the web part implementation as function with zero-argument. We also can define function with arguments, it's called mixed method :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}
```

Here we defined a local method *appendVerSfx*, and then defined a mixed method to use it. The mixed method is used to generate javascript elements with name and version arguments.

Here is how to use it :

```html
@{ master = "mymaster.master" }

@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}
```

It's just like how to declare web parts, but there are a big different between them, when using mixed methods, the mixed method's definition are already know, when declare the web parts, their definition are unknow.

The result would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript" src="/js/index.js?v=3"></script>
	</head>
	<body>

	</body>
</html>
```

The lua blocks can also be used in a web part or mixed method like :

```html
@body{
	<p>
		@ {
			local hour, msg = tonumber(os.date():match("(%d+):"))
			if hour < 10 then
				msg = "Good morning"
			elseif hour > 20 then
				msg = "Good night"
			else
				msg = "Have a nice day"
			end
		}
		@msg
	</p>
}
```

Beware of the indents, the render engine don't do a semantic analysis for the code(but it'd help you to indicate the bugs), so it won't know where the block stoped if the indents don't match. The output should be :

```html
<p>
	Good night
</p>
```


### Helper Page (.helper)

The mixed methods are generaly used as help methods, so it's better to store them in one file, those files are helper pages. Unlike other type pages, the helper page would be converted to an interface, so it can be used by any other page classes.

We can set the helper to master page directly, so all the lua server pages that inherit it can use those mixed methods.

With the *globalhelper.helper* :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}
```

Re-write the *mymaster.master* :

```html
@{ helper = "globalhelper.helper" }

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>@{title My web site}</title>
		@{jspart <!-- javascript placeholder -->}
	</head>
	<body>
		@{body}
	</body>
</html>
```

So the *index.lsp* :

```html
@{ master = "mymaster.master" }

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}
```


### Embed Page (.embed)

By using `@[path default]`, we can embed other page files into the page. Normally, require the file with ".embed" suffix, but master and serer page can also be used(not recommend).

So with the given *notice.embed* file :

```html
<h2>
	Here is a description for test page<br/>
	To show how to use embed web pages.
</h2>
```

Re-write the *index.lsp* :

```html
@{ master = "mymaster.master" }

@body{
	@[notice.embed <!-- Notice placeholder -->]
}
```

And the result would be

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<h2>
			Here is a description for test page<br/>
			To show how to use embed web pages.
		</h2>
	</body>
</html>
```

If delete the *notice.embed* file, the output would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<!-- Notice placeholder -->
	</body>
</html>
```

It's also possible to use the inline code in the *path* and *default*, since it would required some parameters, it's better to define it in the helper file - *globalhelper.helper* :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@javascriptInc(name, version, id) {
	<script type="text/javascript">
		@[/js/@appendVerSfx(name, nil, '.js') // /js/@appendVerSfx(name, version, '.js')]
	</script>
}
```

Now, for the *index.lsp* :

```html
@{ master = "mymaster.master" }

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascriptInc("index", 3) }
}
```

If the js file not existed :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript">
			// /js/index.js?v=3
		</script>
	</head>
	<body>

	</body>
</html>
```

If it existed :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript">
			$(function(){
				var _Ver = 1.0;
			})
		</script>
	</head>
	<body>

	</body>
</html>
```

The css files can also be emebed into page files. It's very useful to save the css and js in the page during development, you can easily change the whole behaviors only with several codes in the helper files.

The js and css files are all static files, if they existed as links, those files would be handled by a web server. If they are marked as embed, they'll be loaded into classes, this is done by **System.Web.JavaScriptLoader** and **System.Web.CssLoader**, the two loaders don't use the **System.Web.PageRenderEngine**, so the js and css file's content are written to the reponse directly.


### Inner Request Page

Besides the embed pages, we also could embed the response of other request, like response from a static route handler, or a controller of the MVC framework. Since the request is raised on the server, it's called the inner request, to diff it from the embed pages, we use another style :

```html
@[~path (param, httpmethod)]
```

Like the embed page, the in-line code can be used in the path, the params will be used as the querystring or form based on the http method(default is GET)

Here is an example

```html
@[~/tag/list {id=1}]
```

If the params are only a table, the parentheses can be omit. If the param and httpmethod are all omit, the request of the current page will be send to the inner request, so it'd get the query string or form.


### Lua Code file (.lua)

For one http request, the Lua Server Page's execution will be divided into two steps :

* Call the page object's *OnLoad* method with the http context object, and generate the response header, so if you need validate request's parameters or redirect to other url, you should do it here.

* Call the page object's *Render* method to generate the response body. The *Render* method is generate by the render engine, so you shouldn't care about it.

To define the *OnLoad* method, we can do it within the *index.lsp* by using block code :

```html
@{ master = "mymaster.master" }

@{
	function OnLoad(self, context)
		-- Generate a cookie
		context.Response.Cookies["TestCookie"].Value = "Test"
		context.Response.Cookies["TestCookie"].Expires = System.Date.Now:AddMinutes(10)
	end
}
```

It'd be more clear to split the code and the html template, we can define the code part in a lua file, and then bind it to the *index.lsp*.

Here we define the *index.lua* :

```lua
class "Index" {}

function Index:OnLoad()
	self.PageTitle = "Test Page"

	self.Data = {
		{ Name = "Ann", Age = 12 },
		{ Name = "King", Age = 32 },
		{ Name = "July", Age = 22 },
		{ Name = "Sam", Age = 30 },
	}
end
```

We define the class *Index* in the first line, the class's name should be the same with the file's name(case ignored), we don't give it the super class and other settings because that would be easy to set in the *.lsp* file.

Then give it an *OnLoad* method, in the method, we just init it with *PageTitle* and *Data* values.

Now, we can use *PageTitle* and *Data* in the *index.lsp* :

```html
@{ master="mymaster.master", code="index.lua" }

@title{
	@self.PageTitle
}

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}

@body{
	<table border="1">
		<thead>
			<tr>
				<th>Person Name</th>
				<th>Person Age</th>
			</tr>
		</thead>
		<tbody>
		@> for _, data in ipairs(self.Data) do
			<tr>
				<td style="background-color:cyan">@data.Name</td>
				<td>@data.Age</td>
			</tr>
		@> end
		</tbody>
	</table>
}
```

The *self* is the object created by the page class to handle the http request, you can use it in any web parts, html helpers, inline and full-line codes, it can't be used in local functions unless you pass the self to them.

The output is :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Test Page</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript" src="/js/index.js?v=3"></script>
	</head>
	<body>
		<table border="1">
			<thead>
				<tr>
					<th>Person Name</th>
					<th>Person Age</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td style="background-color:cyan">Ann</td>
					<td>12</td>
				</tr>
				<tr>
					<td style="background-color:cyan">King</td>
					<td>32</td>
				</tr>
				<tr>
					<td style="background-color:cyan">July</td>
					<td>22</td>
				</tr>
				<tr>
					<td style="background-color:cyan">Sam</td>
					<td>30</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
```

Normally we don't need to use the Lua server page and its lua files, the MVC framework is a more better choice.


## MVC框架 - System.Web.MVC

We use the ".view" files as the view, it also use the **PageRenderEngine** so it follow the same rules of the ".lsp" files. Unlike the lua server page, the business code is done in the controllers, not the page class.

We also use the dynamic route to load the controllers, so the first thing is register a route map the url to the controllers:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

main("/user")
```

This is a special route settings, besides the Lua patterns, the route pattern also support a special usage:

* the `{xxxx}` will be used as a capture
* the `{xxxx?}` means the section can match empty string(ignored), the "/" after it will also be ignored
* the `{xxxx|pattern}` the pattern after the "|" will be used to match the string, they are normal Lua patterns
* All captures will be send to the function

The first return value of the function will be used to retrieve the request handler class, and the others values will be used as the init-table for the class to generate the object to handle the request.

Here is some examples:

Url                 |Path                              |Init-table
:-------------------|:---------------------------------|:--------------------
/                   |/controller/homecontroller.lua    |{ Action = "index" }
/user               |/controller/usercontroller.lua    |{ Action = "index" }
/user/profile       |/controller/usercontroller.lua    |{ Action = "profile", ID = 1 }
/topic/list/1       |/controller/topiccontroller.lua   |{ Action = "list", ID = 1 }


### System.Web.Controller

Save the previous code into a file as *test.lua*, and save the below code as *usercontroller.lua* in the same directory of the test file:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	function index(self, context)
		self:Text("This is the home page of user")
	end
end)
```

We don't need to set a module for the file, since it's loaded by the Application "TestWebApp", the file will be processed in the application.

Now you can process the test file, the result should be

```lua
-- This is the home page of user
main("/user")
```

The `__Action__` attribute is used to bind the *Action* to the method, it has two constructors:

Constructor Arguments                                 |Description
:-----------------------------------------------------|:-----------------------------
action: String, method: HttpMethod/HttpMethod.ALL     |Bind the method to the action with the http method
method: HttpMethod/HttpMethod.ALL                     |Use the method name as action, and bind the method to the action with the http method

The **Controller** class has provided several methods to generate the outputs:

Method                  |Arguments                             |Description
:-----------------------|:-------------------------------------|:--------------------------------
Text                    |text: String                          |Send the text as response
Text                    |iter: Functon, ...: Any * 0           |Send the text generated from the iterator as response
View                    |path: String, ...: Any * 0            |Render a page from file with the data as response
Json                    |data: Any, type: AnyType/nil          |Format the data as JSON format and send it as response
Redirect                |path: String, raw: Boolean/false      |Redirect to another url
NotFound                |                                      |Return 404

First let's save the below template as *user.view* in the same directory:

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Hi, I'm @self.name of @self.age years old</p>
	</body>
</html>
```

Then change the *usercontroller.lua* to:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	function index(self, context)
		self:Text("This is the home page of user")
	end

	__Action__()
	function data(self)
		self:Json({ name = "Ann", age = 21 })
	end

	__Action__()
	function view(self)
		self:View("user.view", { name = "Ann", age = 21 })
	end
end)
```

We'll have the result like:

```lua
-- This is the home page of user
main("/user")

-- {"name":"Ann","age":21}
main("/user/data")

-- <html>
--     <head>
--         <title>Ann</title>
--     </head>
--     <body>
--         <p>Hi, I'm Ann of 21 years old</p>
--     </body>
-- </html>
main("/user/view")
```

You can also use the `__View__`, `__Text__`, `__Json__` attribute on them:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	__Text__() function index(self, context)
		return "This is the home page of user"
	end

	__Action__()
	__Json__() function data(self)
		return { name = "Ann", age = 21 }
	end

	__Action__()
	__View__"user.view" function view(self)
		return { name = "Ann", age = 21 }
	end
end)
```

With those attributes, it's very simple to toggle the response format.


## 表单验证

Each http request will bring in the query string or form datas, we need to validate them and convert them to code type values, there is no need to let the developers keep doing this for each request handlers or controller actions.

The `System.Web.__Form__` attribute is used to bind the form validation informations to the handlers or actions, and will finish the validation and conversion, the result will be passed to the handlers or actions.

Let's start with an example, continue use the action test, so you only need to replace the code in the *usercontroller.lua*.

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ {
		name  = { type = String, require = true },
		age   = { type = Number, require = true },
	}
	__Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end
end)
```

The result would be
```lua
-- {"Form":{"name":"ann","age":"2n1"},"Error":{"age":"the %s must be number"}}
main("/user/query", { name = "ann", age = "2n1" })

-- {"Form":{"name":"ann"},"Error":{"age":"the %s can't be nil"}}
main("/user/query", { name = "ann" })
```

For the error messages, you can use `Struct.GetErrorMessage(msg, "age")` to get the error message to be shown on the page.

If you noticed, the `__Form__` will receive a table of the struct type definition, and in it, the table will also be used to create a member struct type used to validate the query string or the form.

It also support complex query structure like :

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ {
		person = struct {
			struct {
				name = String,
				age  = Number,
			}
		}
	}
	__Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end
end)
```

That means the person is a array struct, whose elements is a table with *name* and *age* values. So the test result will be:

```lua
-- {"Form":{"person":[{"name":"Ann","age":21},{"name":"Ben","age":23}]}}
main("/user/query", {
	["person[1].name"] = "Ann",
	["person[1].age"]  = "21",
	["person[2].name"] = "Ben",
	["person[2].age"]  = 23,
})

-- {"Form":{"person":[{"name":"Ann","age":"n"},{"name":1,"age":23}]},"Error":{"person":[{"age":"the %s must be number"},{"name":"the %s must be string, got number"}]}}
main("/user/query", {
	["person[1].name"] = "Ann",
	["person[1].age"]  = "n",
	["person[2].name"] = 1,
	["person[2].age"]  = 23,
})
```

If there is no error, the *err* argument will be nil, so the developers can check it to decide which response should be sent.

You can define custom struct to provide special error message, but keep in mind, if a value must be number, your custom struct must use the **Number** or any struct type based on the **Number** as its base type, so the validation system know that the value should be converted to a number.


## 用户认证

Before process the handlers or actions, we may need to check whether the user is login, or the user has the authority to access the url.

The **PLoop** has provided a `System.Web.__Login__` attribute to simple the task. It'd provide the login validation and the priority checking. You always can create your own features to replace it.


### Login validation

The `__Login__` will check the session if it has a special key saved in the session, if so, the login validation is passed and the process will be turn to the real handlers or actions.

If the key don't existed, the system will redirect the client to the login page with the current url, so when the user login, he will be redirected to the previous url.

There are three settings must be made, the *Key* in the session, the *LoginPage* that where should be redirected to, and the *PathKey* that send to the *LoginPage* with the current url.

The Application has a property `_Config` can be used for configurations(see the 014.configuration for more informations), those can be set like :

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	-- Configuration
	_Config            = {
		Validator      = {
			Key        = "userid",
			LoginPage  = "/user/login",
			PathKey    = "path",
		}
	}

	-- Route
	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)
```

Here is an usage example:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ { person = struct { struct { name = String, age  = Number, } } }
	__Login__() __Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end

	__Action__("login", HttpMethod.GET) __View__"login.view"
	function loginview() end

	__Form__ {
		userid  = { type = String, require = true },
		password= { type = Password, require = true },
		path    = String,
	}
	__Action__("login", HttpMethod.POST) __Redirect__()
	function login(self, context, form, err)
		if err then return "/user/login" end
		context.Session.Items["userid"] = form.userid
		return form.path or "/"
	end
end)
```

If the user is not login, access the `/user/query` will be redirected to `/user/login?path=%2Fuser%2Fquery`

You should set the *Key* to session and redirect to the *Path* in the login page handlers.


### Authority Checking

The priority checking is a little complex, since the system won't know how your authority system is designed.

First you should give parameters to the `__Login__` attribute as the authority requirement for the url.

Then you must add an **AuthorityChecker** function in the `_Config.Validator`, the function will recieve the context and the authority requirement and return two value.

If the first value is true, the user passed the checking, the handler will process the operations, if false, the second value will be used as the redirect path.

Here is an example:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	-- Configuration
	_Config                  = {
		Validator            = {
			Key              = "userid",
			LoginPage        = "/user/login",
			PathKey          = "path",
			AuthorityChecker = function (context, requirement, path)
				if context.Session.Items.level >= requirement then
					return true
				else
					return path or "/user/forbidden"
				end
			end,
		}
	}

	-- Route
	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
```

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ { person = struct { struct { name = String, age  = Number, } } }
	__Login__(4, "/user") __Action__() __Json__()
	function query(self, context, form, err)
		return { Form = form, Error = err }
	end

	__Action__("login", HttpMethod.GET) __View__"login.view"
	function loginview() end

	__Form__ {
		userid  = { type = String, require = true },
		password= { type = Password, require = true },
		path    = String,
	}
	__Action__("login", HttpMethod.POST) __Redirect__()
	function login(self, context, form, err)
		if err then return "/user/login" end
		context.Session.Items["userid"] = form.userid
		context.Session.Items["level"] = 1
		return form.path or "/"
	end

	__Action__()
	__Text__() function forbidden()
		return "You have no right"
	end
end)
```


## 上下文处理器

The process of the request is defined in the **System.Web.IHttpContextHandler**, all context handlers should extend the interface, the **Controller** extend it, the static route functions also will be wrapped as an object that extend the interface.

Here is the features provided by the interface

```lua
--- the http context process phase
__Flags__() __Sealed__()
enum "System.Web.IHttpContextHandler.ProcessPhase" {
	"Init",
	"Head",
	"Body",
	"Final"
}

--- the http context handler's priority
__Sealed__() __Default__(0)
enum "System.Web.IHttpContextHandler.HandlerPriority" {
	Highest                 =  2,
	Higher                  =  1,
	Normal                  =  0,
	Lower                   = -1,
	Lowest                  = -2,
}
```

Abstract Property       |Type                   |Default             |Description
:-----------------------|:----------------------|:-------------------|:--------------------
IsRequestHandler        |Boolean                |false               |Gets or sets whether the handler would check the request is already handled, only for init process phase, if the request is handled and the IsRequestHandler is true, the handler won't be use.
ProcessPhase            |ProcessPhase           |Head + Body         |Gets or sets the handler's process phase
Priority                |HandlerPriority        |Normal              |Gets or sets the handler's priority
AsGlobalHandler         |Boolean                |false               |Gets or sets whether the context handler is used as global handler.
Application             |Application            |                    |Gets or sets the target web application of the global handler
-------------------------------------------------------------------------------------------


Abstract Method         |Arguments                                   |Description
:-----------------------|:-------------------------------------------|:--------------------
Process                 |context: HttpContext, phase: ProcessPhase   |Process the http request
-------------------------------------------------------------------------------------------


Method                  |Arguments                                   |Description
:-----------------------|:-------------------------------------------|:--------------------
RegisterToContext       |context: HttpContext/nil                    |Register self to the context or the current context as temporary handlers

Take the **Route** as example, all routes are managed by the **RouteManager**, each web application has only one route manager, the route manager is a global handler register for the **ProcessPhase.Init** phase, it's a request handler, so it won't be processed when the request is aleady handled.

The global handler means it'll be used for each request, so the route manger will check the request url to find a matched route, if it get one, it'll try get the temp context handler from it, like use the static route handlers directly, or generate a handler from the class generated from the target file. The handler will call its **RegisterToContext** method reigster itself to the context as a temp handler(that's done by the interface itself).

There are three type context handlers.

* Temp handler                   - The static route handlers, the controller, the Lua sever pages are all temp handlers, they are registered to the http context, if the response is sent to the client, the http context will be disposed, so the temp handlers will be released.

* Application Global Handler     - Those handlers are registered as global handler with application, so it'll only works for the http context of the same applications, the route managers are application global handlers.

* Server Global Handler          - Those handlers are registered as global handler without application, it works for all http context created in the server.


Take an example from [NgxLua][], this is used to save the cookies to the reponse, it's server global handler:

```lua
-- the handler to send cookies
IHttpContextHandler {
	ProcessPhase    = IHttpContextHandler.ProcessPhase.Head,
	Priority        = IHttpContextHandler.HandlerPriority.Lowest,
	AsGlobalHandler = true,
	Process = function(self, context, phase)
		if not context.IsInnerRequest then
			local cookies = context.Response.Cookies
			if next(cookies) then
				local cache = {}
				local cnt = 1
				for name, cookie in pairs(cookies) do
					cache[cnt] = tostring(cookie)  -- The http cookie objects can be serialized through __tostring
					cnt = cnt + 1
				end
				ngx.header['Set-Cookie'] = cache
			end
		end
	end,
}
```

The **IHttpContextHandler** has anonymous class, so can be used to generate the handlers directly.

We could use those global handlers to collect informations, like day-access times:

```lua
--- the handler to send cookies
IHttpContextHandler {
	ProcessPhase    = IHttpContextHandler.ProcessPhase.Head,
	Priority        = IHttpContextHandler.HandlerPriority.Lowest,
	AsGlobalHandler = true,
	Application     = app,
	Process = function(self, context, phase)
		if not context.IsInnerRequest then
			with(Redis())(function(redis)
				local count = redis:Execute("INCR", "DAY_ACCESS_COUNT")
				if count == 1 then
					local dt= Date.Now
					redis:SetExpireTime("DAY_ACCESS_COUNT", Date(dt.Year, dt.Month, dt.Day, 23, 59, 59))
				end
			end)
		end
	end,
}
```

This is an application global handlers used to save the access count.

The process of a request is splitted into four phases:

* Init    -- The init phase, used to prepare the context handlers, like register the temp handlers
	* Process the server global handlers
	* Process the application global handlers
* Head    -- The head phase, used to prepare the response head informations
	* Process the temp handlers
	* Process the application global handlers
	* Process the server global handlers
	* Send the headers to the client
* Body    -- The body phase, only processed when the request is not redirected
	* Process the temp handlers
	* Process the application global handlers
	* Process the server global handlers
	* Close the response
* Final   -- The final phase, used to release resources
	* Process the temp handlers
	* Process the application global handlers
	* Process the server global handlers

The handlers will only be processed for its register phases.

It's very interesting in the **Controller**, it's logic is processed over the three phases:

Let's take out the **Text** method as an example:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "This is a test message"

		self:Text(text)

		text = nil
	end
end)
```

We expand the **Text** method, it works like:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "This is a test message"
		print("[PHASE]", context.ProcessPhase)

		local res       = self.Context.Response
		if res.RequestRedirected or res.StatusCode ~= HTTP_STATUS.OK then return end

		res.ContentType = "text/plain"
		coroutine.yield() -- finish head sending

		print("[PHASE]", context.ProcessPhase)

		res.Write(Web.ParseString(text))

		coroutine.yield() -- finish body sending

		print("[PHASE]", context.ProcessPhase)
		text = nil
	end
end)
```

The result would be

```lua
-- [PHASE]    2
-- [PHASE]    4
-- [PHASE]    8
-- This is a test message
main("/user/query")
```

So after the `self:Text(text)`, it's very safe to release resouces or finish other tasks, it won't block other requests.


## 错误处理

The web system would track the errors during the process, it also will track the errors of the template system which is more hard to debug.

But first, we need give it an error handler, it's also a configuration :

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", System.Web.IHttpContextHandler.ProcessPhase }

	_Config = {
		ErrorHandler            = function(err, stack, context)
			if context.ProcessPhase == ProcessPhase.Final then
				error(err, stack)
			else
				context:ProcessInnerRequest("/error", { error = err })
				context.Response:Close()
			end
		end,
	}

	__Route__ "/error"
	__View__ "error.view" [[
		<html>
			<head>
				<title>Error</title>
			</head>
			<body>
				<p>@self.error</p>
			</body>
		</html>
	]]
	function errorhandler(context)
		return { error = context.Request.QueryString.error }
	end

	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

main("/user/query")
```

We give an **ErrorHandler** to the `_Config`, it'll receive error, stack and context, we checked the `context.ProcessPhase`, since we can't send the response when it's already done, then we pass the error to the `/error` url.

Let's modify the *usercontroller.lua* and see the result:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "hello" .. context.Request.QueryString.name
		self:Text(text)
	end
end)
```

```html
<html>
	<head>
		<title>Error</title>
	</head>
	<body>
		<p>xxxxx/usercontroller.lua:5: attempt to concatenate a nil value (field 'name')</p>
	</body>
</html>
```

Then let's modify the *user.view* and *usercontroller.lua*:

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Score: @(self.data > 60 and "Pass" or "Failed")</p>
	</body>
</html>
```

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		self:View("user.view", { name = "Ann", data = nil })
	end
end)
```

We'll get the result:

```html
<html>
	<head>
		<title>Ann</title>
	</head>
	<body>
		<p>Score: 		<html>
			<head>
				<title>Error</title>
			</head>
			<body>
				<p>xxxxxx/user.view:6:  attempt to compare number with nil</p>
			</body>
		</html>
```

Well, it's a little odd, since the response is sent as stream, we may need see the source of the page to find out the error messages.


## 相对路径和绝对路径

In the above examples, we use paths for master, helper, code, view and etc. Here are some details about the path :

* The root path can be get by HttpRequest.Root.

* Path started with "/" is an absolute path, combine the root path and the absolute path is the target file's path.

* Path not started with "/" is a relative path, combine current file's directory and the relative path is the target file's path. So if we have a controller '/controller/usercontroller.lua', it use a view 'view/profile.view', the view's absolute path should be '/controller/view/profile.view', you can also use `..` for the parent directory.


## 配置

Like the `_Config` of the web application, the **System.Web.Config** provide the configurations for all applications in the server.

There are configurations defined in the **System.Web**:

Configuration Name   |Type                       |Description
:--------------------|:--------------------------|:--------------------------------
Debug                |Boolean                    |Whether reload the resources files when modified, the system will only reload dynamic features like views, controllers.
LogLevel             |Logger.LogLevel            |Change the log level for the **PLoop** system
LogHandler           |Callable                   |Add a log handler
ErrorHandler         |Function                   |Add an error handler for all applications, normally should only be set by the web application

We must turn off the **Debug** when publish the web server, the modified time check is a greater cost. Only useful under development mode.


## 视图的配置

The template system also registered the configurations to the **System.Web.Config.View** and the web application's `_Config.View`.

Here is an example:

```lua
_Config = {
	View                    = {
		Default             = {
			master          = nil,
			helper          = nil,
			reload          = false,
			encode          = true,
			noindent        = true,
			nolinebreak     = true,
			linebreak       = "\n",
			engine          = nil, -- default System.Web.PageRenderEngine
			asinterface     = nil,
			export          = {
				error       = function(message, target)
					return Struct.GetErrorMessage(message, target)
				end,
			},
		},

		ViewPage             = {
			reload           = true,
		},
	},
}
```

The *View* contains all settings for each type template files:

Name             |Super                 |suffix                |Description
:----------------|:---------------------|:---------------------|:--------------------------------
Default          |                      |.*                    |For all template files
HtmlPage         |Default               |.*                    |For all html page files
StaticFile       |Default               |.*                    |For all static files
ViewPage         |HtmlPage              |.view                 |For view files
EmbedPage        |HtmlPage              |.embed                |For embed page files
PageHelper       |HtmlPage              |.helper               |For helper files
LuaServerPage    |HtmlPage              |.lsp                  |For the lua server page files
MasterPage       |HtmlPage              |.master               |For the master page files
CssFile          |StaticFile            |.css                  |For css files that used as resources
JavascriptFile   |StaticFile            |.js                   |For js files that used as resources

The settings will use its super's settings if it don't have one.

For those sub configurations:

Name           |Type                          |Description
:--------------|:-----------------------------|:-------------------------------
master         |String                        |The master page for all the type files
helper         |String                        |The helper page for all the type files
reload         |Boolean                       |Set all the type files whether reload when modified
encode         |Boolean                       |Set all the type files whether encode every expression
noindent       |Boolean                       |Set all the type files whether don't output indents
nolinebreak    |Boolean                       |Set all the type files whether don't output line break
linebreak      |String                        |Set the linkbreak to all the type files
engine         |- System.Web.IRenderEngine    |Set the render engine to the type files, normally don't set it
asinterface    |Boolean                       |Set all the type files whether the returned type should be an interface
export         |Table                         |A table whose items will be exported to the environment where the resource is generated, so it can use all variables defined in the table

The configuration in the resource file's head line will override the settings provided here.

Normally only *noindent*, *nolinebreak* and *export* are need.

With the previous settings, a view like :

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Score: @(math.random(100) > 60 and "Pass" or "Failed")</p>
	</body>
</html>
```

The result would be :

```html
<html><head><title>Ann</title></head><body><p>Score: Pass</p></body></html>
```

So you can reduce the reponse length just by two settings, you can apply those configuration on the application or on the **Web** for all applications.


## 自定义渲染引擎

The **PLoop** only provied two render engine : **System.Web.PageRenderEngine** used to support a template system like the Razor for Asp.Net, and the **System.Web.StaticFileLoader** used for static files like the css.

Now, we'll see how to create the custom render engines, this is based on the text analysis.

The render engine must extend the **System.Web.IRenderEngine** and provide several methods:

Abstract Method    |Arguments                                        |Description
:------------------|:------------------------------------------------|:-------------------------
Init               |loader: IOutputLoader, config: RenderConfig      |Init the engine with the page loader and the page config
ParseLines         |reader: TextReader                               |Parse the lines and yield all content with type

The **ParseLines** will be called within an iterator, the **IRenderEngine** has extend the **Iterable** interface.

For the static files, the **ParseLines** is defined like :

```lua
function ParseLines(self, reader)
	-- Use yield not return to send back content and other informations

	-- The Render is the start method of the whole page rendering
	-- the system don't care the name of other methods, but this must be
	-- provided by all page classes(or its master page class)
	coroutine.yield(RenderContentType.MixMethodStart, "Render")

	for line in reader:ReadLines() do
		line = line:gsub("%s+$", "")
		coroutine.yield(RenderContentType.RecordLine, line)

		coroutine.yield(RenderContentType.StaticText, line)

		coroutine.yield(RenderContentType.NewLine)
	end

	coroutine.yield(RenderContentType.MixMethodEnd)
end
```

Here is the explains:

* We use the coroutine to yield all the op codes and data to make sure we can track the context of analysis.
* We yield the op code defined in the **RenderContentType**, so the system know how to use it to generate the page classes.
* The **RenderContentType.RecordLine** will be used to map the code line with the template line, so the system know where the bug comes from, it's very important.

Here are the op codes from the **RenderContentType**:

Name               |Parameters                                                       |Description
:------------------|:----------------------------------------------------------------|:------------------------------------
RecordLine         |line:String                                                      |record the line with an auto-incr line number for error location
StaticText         |text:String                                                      |the static text
NewLine            |                                                                 |write a new line
LuaCode            |line:String                                                      |the lua code line like `if xxx then`
Expression         |exp:String                                                       |the expression to be executed and write the result
EncodeExpression   |exp:String                                                       |the expression to be executed and the result must be encoded then sent out
MixMethodStart     |name:String                                                      |start the creation of a mix method, the mix method is also the object method of the generated the class
MixMethodEnd       |                                                                 |end the creation of the previous mix method
CallMixMethod      |name:String, params:String, default:String, issupercall:Boolean  |call a mix method with params, if not existed, use the default, if issupercall, then the super class's mix method will the name will be used, like the usage of the `@{super:body}`
RenderOther        |path:String, params:String, default:String                       |Render other files, like the embed pages
InnerRequest       |url:String, params:String                                        |Render with an inner request call


So with those codes, we can change a template file into the definition of the page class.

Now we have a **index.wf** template:

```html
html
	head
		title
			> my web site
	body
		div #mainDiv .center
			p #random style='width:100px'
				> random is {{ math.random(10000) }} pts
```

We'll create a custom engine and register a resource loader based on the engine for it:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"
require "PLoop.System.IO"

PLoop(function(_ENV)
	import "System.IO.Resource"
	import "System.Web"

	-- Define the render engine
	class "WaterFallEngine"(function (_ENV)
		extend "IRenderEngine"

		local yield 	= coroutine.yield

		local NOT_CHILD = 0
		local NODE_ELE 	= 1
		local TEXT_ELE 	= 2

		local function parseLine(self, reader, chkSpace, isFirstChild)
			line = self.CurrentLine or reader:ReadLine()

			self.CurrentLine = nil

			if not line then return NOT_CHILD end
			line = line:gsub("%s+$", "")

			local space, tag, ct = line:match("^(%s*)(%S+)%s*(.*)$")

			space = space or ""

			if tag == ">" then
				-- It's a text element
				-- for "random is {{ math.random(10000) }} pts"

				local startp = 1
				local expSt, expEd = ct:find("{{.-}}", startp)

				while expSt do
					-- "random is " is static text
					yield(RenderContentType.StaticText, ct:sub(startp, expSt - 1))

					-- math.random(10000) is an expression
					yield(RenderContentType.Expression, ct:sub(expSt + 2, expEd - 2))

					startp = expEd + 1
					expSt, expEd = ct:find("{{.-}}", startp)
				end

				-- The remain " pts" is also static text
				yield(RenderContentType.StaticText, ct:sub(startp))

				return TEXT_ELE
			end

			-- Check if it's a child node
			if not chkSpace or #space > #chkSpace then
				-- This is a node
				-- for "		div #mainDiv .center"

				-- If the node is a child node, we need add a new line
				if chkSpace then
					if isFirstChild then
						yield(RenderContentType.NewLine)
					end

					-- "		" space is static text, don't forget it
					yield(RenderContentType.StaticText, space)
				end

				-- Get id, class and other settings
				local id, cls = "", ""
				local cache = { tag }

				-- Get and remove id from ct
				ct = ct:gsub("#(%w+)", function(w) id = w return "" end)
				if #id > 0 then
					table.insert(cache, ([[id="%s" name="%s"]]):format(id, id) )
				end

				-- Get and remove class from ct
				ct = ct:gsub("%.(%w+)", function(w) cls = cls .. w .. "," return "" end)
				if #cls > 0 then
					table.insert(cache, ([[class="%s"]]):format(cls:sub(1, -2)) )
				end

				-- Get the remain
				ct = ct:gsub("^%s*(.-)%s*$", "%1")
				if ct and #ct > 0 then
					table.insert(cache, ct)
				end

				-- "div #mainDiv .center" -> StaticText: <div id="mainDiv" name="mainDiv" class="center">
				yield(RenderContentType.StaticText, "<" .. table.concat(cache, " ") .. ">")

				-- check the next line
				local firstNode = true

				while true do
					local ret = parseLine(self, reader, space, firstNode)

					firstNode = false

					if ret == TEXT_ELE then
						-- Close the tag
						yield(RenderContentType.StaticText, "</" .. tag .. ">")

						-- Generate a new line
						yield(RenderContentType.NewLine)

						return NODE_ELE
					elseif ret == NODE_ELE then
						-- We have a child node, just keep parsing
					else
						-- we meet the end of the node
						if #space > 0 then
							yield(RenderContentType.StaticText, space)
						end

						-- Close the tag
						yield(RenderContentType.StaticText, "</" .. tag .. ">")

						-- Generate a new line
						yield(RenderContentType.NewLine)

						return NODE_ELE
					end
				end
			else
				-- This is not a child node, so return to close the previous node
				self.CurrentLine = line

				return NOT_CHILD
			end
		end

		function ParseLines(self, reader)
			yield(RenderContentType.MixMethodStart, "Render")

			parseLine(self, reader)

			-- end
			yield(RenderContentType.MixMethodEnd)
		end
	end)

	__ResourceLoader__"wf"   -- Register for the .wf files
	__PageRender__("WaterFallPage", IOutputLoader, { engine = WaterFallEngine })  -- Bind the render engine
	class "System.Web.WaterFallPage" { IOutputLoader }
end)

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", System.Web.IHttpContextHandler.ProcessPhase }

	_Config = {
		View                = {
			Temporary       = "/temp",
		},
	}

	__Route__ "/index"
	__View__ "/index.wf"
	function index(context)
		return { name = "Ann" }
	end
end)

-- The test code to simulate the http request
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

-- <html>
--     <head>
--         <title>Ann web site</title>
--     </head>
--     <body>
--         <div id="mainDiv" name="mainDiv" class="center">
--             <p id="random" name="random" style='width:100px'>random is 4150 pts</p>
--         </div>
--     </body>
-- </html>
main("/index")
```

In the *app*, we declare a Temporary path `/temp`, the page class's definition will be saved into the target folder for debug if given, here is the generated code for the *index.wf*:

```lua
local _PL_HtmlEncode, tostring = System.Web.HtmlEncode, System.Web.ParseString
function Render(self, _PL_write, _PL_indent)
	_PL_indent = _PL_indent or ""
	_PL_write(_PL_indent)
	_PL_write("<html>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("<head>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("		")
	_PL_write("<title>")
	_PL_write(tostring( self.name ))
	_PL_write(" web site")
	_PL_write("</title>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("</head>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("<body>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("		")
	_PL_write("<div id=\"mainDiv\" name=\"mainDiv\" class=\"center\">")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("			")
	_PL_write("<p id=\"random\" name=\"random\" style='width:100px'>")
	_PL_write("random is ")
	_PL_write(tostring( math.random(10000) ))
	_PL_write(" pts")
	_PL_write("</p>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("		")
	_PL_write("</div>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("</body>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("</html>")
end
```

It's useful when test the custom page render engines.


[PLoop.Browser]: https://github.com/kurapica/PLoop.Browser  "PLoop Lib Browser"
[nginx]: https://www.nginx.com/ "Nginx"
[Openresty]: https://github.com/openresty/lua-nginx-module/ "Openresty"
[NgxLua]: https://github.com/kurapica/NgxLua/ "An implementation for the Openresty"