# System.Web

`System.Web`是**PLoop**提供的独立的类库，需要单独`require "PLoop.System.Web"`来加载，它提供了和平台无关的Web框架。系统目前只支持UTF-8编码。具体实现需要针对平台来提供。

目前的实现有: 对应[Openresty][]服务器的[NgxLua][]，例子可以参考[PLoop.Browser][]，用于通过反射机制展示**PLoop**的类库。


## 目录

* [测试环境](#测试环境)
* [Web APP - System.Web.Application](#systemwebapplication)
	* [Web App的初始化](#web-app的初始化)
	* [nginx.conf配置](#nginx_conf配置)
	* [init.lua初始化](#init_lua初始化)
	* [我们的第一个Web App](#我们的第一个Web-App)
	* [__Route__ 路由管理](#__Route__-路由管理)
	* [`System.Web.__Text__`](#systemweb__text__)
	* [`System.Web.__Json__`](#systemweb__json__)
	* [`System.Web.__Redirect__`](#systemweb__redirect__)
	* [`System.Web.__View__`](#systemweb__view__)
	* [Application的定义](#Application的定义)
		* [Web App作为子网站](#Web-App作为子网站)
		* [Web App的错误处理](#Web-App的错误处理)
* [Web 常量](#Web-常量)
* [编码和解码](#编码和解码)
* [上下文 - System.Web.HttpContext](#上下文---systemwebhttpcontext)
	* [请求 - System.Web.HttpRequest](#请求---systemwebhttprequest)
	* [响应 - System.Web.HttpResponse](#响应---systemwebhttpresponse)
	* [Cookie管理 - System.Web.HttpCookie & System.Web.HttpCookies](#Cookie管理---systemwebhttpcookie--systemwebhttpcookies)
	* [用户会话 - System.Web.HttpSession](#用户会话---systemwebhttpsession)
		* [System.Web.ISessionIDManager](#systemwebisessionidmanager)
			* [System.Web.GuidSessionIDManager](#systemwebguidsessionidmanager)
			* [NgxLua.JWTSessionIDManager](#ngxluajwtsessionidmanager)
		* [System.Web.ISessionStorageProvider](#systemwebisessionstorageprovider)
			* [System.Web.TableSessionStorageProvider](#systemwebtablesessionstorageprovider)
			* [NgxLua.ShareSessionStorageProvider](#ngxluasharesessionstorageprovider)
			* [NgxLua.RedisSessionStorageProvider](#ngxluaredissessionstorageprovider)
			* [NgxLua.JWTSessionStorageProvider](#ngxluajwtsessionstorageprovider)
* [页面渲染](#页面渲染)
	* [Lua Server Page (.lsp)](#lua-server-page-lsp)
	* [Master Page (.master)](#master-page-master)
	* [Super web part](#super-web-part)
	* [Mix HTML with lua](#mix-html-with-lua)
		* [Block](#block)
		* [Inline](#inline)
		* [Full-line](#full-line)
		* [Mixed Method](#mixed-method)
	* [Helper Page (.helper)](#helper-page-helper)
	* [Embed Page (.embed)](#embed-page-embed)
	* [Inner Request Page](#inner-request-page)
	* [Lua Code file (.lua)](#lua-code-file-lua)
* [MVC框架 - System.Web.MVC](#MVC框架---systemwebmvc)
	* [System.Web.Controller](#systemwebcontroller)
* [表单验证](#表单验证)
* [用户认证](#用户认证)
	* [Login validation](#login-validation)
	* [Authority Checking](#authority-checking)
* [上下文处理器](#上下文处理器)
* [错误处理](#错误处理)
* [相对路径和绝对路径](#相对路径和绝对路径)
* [配置](#配置)
* [视图的配置](#视图的配置)
* [自定义渲染引擎](#自定义渲染引擎)


## 测试环境

**PLoop**提供的Web框架是平台无关的，但为了更容易展现框架功能，我们选择[Openresty][]作为测试平台，目前只有[NgxLua][]针对[Openresty][]提供了**PLoop** Web框架的实现。如果期望在特定服务器上实现，可以参考[NgxLua][]，实际并不复杂。

测试环境采用的软件环境是(CentOS7 + Mysql 8 + Redis + Openresty)：

1. CentOS 7，请到http://isoredirect.centos.org/centos/7/isos/x86_64/，下载，作为测试环境，推荐使用[Oracle VM VirtualBox](https://www.virtualbox.org/)创建虚拟机，进行最小安装即可。

	如果采用虚拟机的话，配置时，网卡需要开启两个，一个是NAT网络，用于访问外网，另一个是Host-Only网络，这样主机可以直接通过IP访问虚拟机内开启的Web服务器。

	首次进入系统后，最好检查下/etc/sysconfig/network-scripts/ifcfg-enp0s8文件，可以使用vi编辑，确保`ONBOOT=yes`，开机加载。最好固定IP地址(IPADDR)，方便主机访问。

	**为了简单起见，下述操作都使用root账号进行，权限管理和优化都不会涉及**。


2. 服务器采用[Openresty][]，安装可以参考[Openresty的安装](https://openresty.org/cn/installation.html)，也可以直接尝试下面的操作：

	```shell
	yum install yum-utils
	yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo
	yum install openresty
	yum install openresty-resty
	```

	正常安装后，将路径添加到PATH，也可以写入~/.bashrc or ~/.bash_profile文件，确保开机加载

	```shell
	export PATH=/usr/local/openresty/bin:/usr/local/openresty/nginx/sbin:$PATH
	```

	测试下面的命令，如果能正确输出，说明安装正常，路径配置也正常了。

	```shell
	resty -e 'print("hello, world")'
	```

	新装的系统可能没开放80端口，需要先开启

	```shell
	firewall-cmd --zone=public --add-port=80/tcp --permanent
	```

3. 数据库采用Mysql 8.0，从[Mysql官网](https://dev.mysql.com/downloads/repo/yum/)可以查询最新的对应CentOS 7的版本，也可以采用下面的操作：

	安装Mysql 8.0，并设置开机启动

	```shell
	yum install wget
	cd /tmp

	wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm
	md5sum mysql80-community-release-el7-3.noarch.rpm
	rpm -ivh mysql80-community-release-el7-3.noarch.rpm
	yum install mysql-server -y
	systemctl start mysqld
	systemctl status mysqld
	```

	查看root@localhost的临时密码

	```shell
	grep 'temporary password' /var/log/mysqld.log

	mysql -u root -p
	```

	获取的临时密码等候就可以修改root密码，添加实际用户，这里简单创建一个具有所有权限的admin:

	```sql
	ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';
	CREATE USER 'admin'@'%' IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY '管理员密码';
	GRANT ALL PRIVILEGES ON * . * TO 'admin'@'%';
	FLUSH PRIVILEGES;
	```

	之后创建一个新的`PLoop`数据库，用于测试。

	```sql
	CREATE DATABASE PLoop;
	EXIT
	```

	暂时我们不创建数据库，稍后在MVC模块演示如何通过类型反射读取Model，自动生成数据库表结构。

4. 缓存数据库使用[Redis](https://github.com/antirez/redis)，可以在网站中拿去最新的版本，下面安装以5.0.6版为准：

	```shell
	cd /usr/local
	mkdir redis
	cd redis

	wget https://github.com/antirez/redis/archive/5.0.6.tar.gz
	tar -zxvf 5.0.6.tar.gz

	yum install gcc
	cd redis-5.0.6

	make
	cd src
	make install
	```

	安装后需要配置开机启动

	```shell
	cdd /etc
	mkdir redis
	cp /usr/local/redis/redis-5.0.6/utils/redis_init_script /etc/init.d/redisd
	cp /usr/local/redis/redis-5.0.6/redis.conf /etc/redis/6379.conf
	vi /etc/redis/6379.conf
	```

	最后一行是编辑6379.conf文件，找到里面的`daemonize=no`，需要修改为yes，然后保存退出。

	启动redis服务:

	```shell
	service redisd start
	```

	那么默认我们的Redis服务器运本地127.0.0.1的6379端口。

5. 针对使用[Oracle VM VirtualBox](https://www.virtualbox.org/)的用户，可以通过共享文件夹的形式，在Windows系统中编写代码，CentOS 7共享该目录，可以比较直接的运行整个网站，在开启Debug模式时，Windows上编辑代码文件，变更也会即时反映在CentOS上运行的网站上。

	首先需要选择安装的虚拟机，点击设置-共享文件夹，然后添加一个本地目录作为共享目录，分配名称为www（可自行修改），选择自动挂载。确定即可。

	然后，启动虚拟机，在虚拟机的界面，选择设备-安装增强功能，这样VBox会挂载一个iso，等待安装。

	准备工作

	```shell
	yum update
	yum install gcc kernel-devel make

	reboot
	```

	安装VBox增强功能。

	```shell
	mkdir /cdrom
	mount /dev/cdrom /cdrom

	/cdrom/VBoxLinuxAdditions.run
	```

	加载共享目录到 ~/www，为了方便，创建一个start.sh命令文件用于启动nginx，创建一个reload.sh命令文件用于重启nginx

	```shell
	cd ~
	mkdir www
	mount -t vboxsf www ~/www/

	cat > start.sh <<EOF
	mount -t vboxsf www ~/www/
	cd www
	nginx -p `pwd`/www -c conf/nginx.conf
	EOF

	cat > reload.sh <<EOF
	cd www
	nginx -p `pwd`/www -s stop
	nginx -p `pwd`/www -c conf/nginx.conf
	EOF

	chmod +x start.sh
	chmod +x reload.sh
	```

	之后，程序部署到共享目录后，通过

	```shell
	cd ~
	./start.sh
	```

	启动网站，通过

	```shell
	cd ~
	./reload.sh
	```

	来重启网站，到此我们测试环境的准备工作就完成了。**之后所有提及的文件路径，都以这个共享文件夹为根路径**。


## Web App - System.Web.Application

### Web App的初始化

一个Web App(`System.Web.Application`类的对象)是一个单独的web服务，一个`nginx`服务可以运行多个Web App，每个App会具有自己独立的配置，路由，控制器等等。首先我们构建一个Web App然后在我们的测试环境中启动它:

简单起见，以下初始化操作在CentOS中完成，分别是拷贝默认的nginx配置以及下载**PLoop**及**NgxLua**两个库:

```shell
cd ~/www/
mkdir conf
cp /usr/local/openresty/nginx/conf/* ~/www/conf

yum install git -y

git clone https://github.com/kurapica/PLoop
git clone https://github.com/kurapica/NgxLua
```

### nginx.conf配置

之后打开/conf/nginx.conf文件（以后的文件编辑操作可以在windows上完成，或者任意你习惯的编辑方式），将内容替换为:

```conf
user root;

pid logs/nginx.pid;

events {
	worker_connections  1024;
}

http {
	include mime.types;

	lua_shared_dict plbr_session_storage 10m;
	lua_shared_dict ngxlua_file_lock 100k;

	lua_package_path "${prefix}?.lua;${prefix}?/init.lua;/usr/local/openresty/lualib/?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua";

	init_by_lua_file ./conf/init.lua;

	server{
		listen       80;
		server_name  localhost;

		location / {
			root html;

			# MIME type determined by default_type:
			default_type 'text/html';

			content_by_lua ' PLBR.HttpContext():Process() ';
		}
	}
}
```

user选择root是简单的避免权限问题，实际项目请自行管理权限设置。上面定义了两个共享表，`plbr_session_storage`用于保存用户会话状态，`ngxlua_file_lock`用于提供全局锁的机制，例如加载代码，或者网页模板时，需要加锁，避免同时多个类生成，产生冲突。但一般加载后，除非文件变更需要重载，是不需要再使用全局锁的，所有不会影响服务器的高并发。具体使用在多线程环节介绍。

`lua_package_path`制定了Lua加载库的路径，`${prefix}`是网站的根路径，即 `~/www/`，所以，保存在它下面的**PLoop**和**NgxLua**都可以被正常加载，后面的是[Openresty][]随附的Lua库。基本是常用库。

`init_by_lua_file`指明了启动nginx时，初始化用的Lua文件，通常我们在这个文件中，加载**PLoop**和**NgxLua**库，然后加载各个Web App。

这里我们只加载一个用于浏览**PLoop**提供的类库的Web App，所以，只定义一个server，其中`content_by_lua`是我们处理的入口，其中`PLBR`是我们将要申明的命名空间，通常一个Web APP应该具有一个独立的命名空间，`PLBR.HttpContext`是一个上下文对象，为了在多OS线程平台上使用Lua，我们通常需要一个上下文对象来隔离处理，由上下文对象启动Http请求的处理，这个过程中创建的所有对象都可以在上下文对象中读写值，因为单个系统线程中的Lua操作实际是单线程，所以，这些对象可以没有冲突的通过上下文对象共享值。稍后会详细介绍上下文对象。


### init.lua初始化

创建`/conf/init.lua`文件，这里我们将加载网站的基础代码部分，主要是加载类库和加载Web App，但Web App具体实现会在稍后再定义：

```lua
PLOOP_PLATFORM_SETTINGS = { CORE_LOG_LEVEL = 3, MULTI_OS_THREAD = true, TYPE_VALIDATION_DISABLED = false }

-- NgxLua会加载PLoop
require "NgxLua"

-- 全局配置，不限定哪个Web App
PLoop(function(_ENV)
	-----------------------------------------------------------------------
	--                            全局Web配置                            --
	-----------------------------------------------------------------------
	Web.Config                  = {
		Debug                   = true,
		LogLevel                = System.Logger.LogLevel.Debug,
	}

	-----------------------------------------------------------------------
	--                            线程锁管理器                            --
	-----------------------------------------------------------------------
	NgxLua.LockManager("ngxlua_file_lock")
end)

-- 加载Web App，可以按顺序加载多个
require "plbr"
```

注意，这里通过`PLOOP_PLATFORM_SETTINGS`将`MULTI_OS_THREAD`置为true，Web服务器都是多系统线程的，为了避免冲突，必须开启这个选项。`Web.Config`是Web框架的全局配置，不涉及单个Web App，这里的`Debug`设置为true，那么当资源文件类似网站模板文件修改后，再次访问时，系统会重新加载，这可以比较即时的看到修改结果。但因为需要检查文件修改时间，并且因为资源文件间存在依赖关系（子类，超类），检查文件的数量可能会比较多，仅仅适用于开发阶段，**实施时请务必修改为false**。

`NgxLua.LockMananger`是使用[Openresty][]提供的共享表来实现线程锁，它没有太多的可以配置的属性，基本保持这样的申明处理即可。这里使用的`ngxlua_file_lock`是在`nginx.conf`中申明的。


### 我们的第一个Web App

创建`/plbr/`目录，这个目录将是我们实际的项目代码目录，首先创建`/plbr/init.lua`文件，这个文件将保存我们在初始化时需要加载的所有文件。这些文件通常是路由，模型，常用类型等的定义。这些必须在初始化时加载，并且系统无法在运行过程中重新加载（使用上面的`./reload.sh`来重新初始化整个网站）。

在这个文件中，我们将初始化我们的Web App，并加载一个路由文件。

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	-- 定义PLBR.HttpContext，它继承了NgxLua.HttpContext
	-- 唯一功能是构造时，绑定自己的Application为当前的Web App
	-- 注意，Application继承了`System.Module`，所以可以作为
	-- 环境使用，这里的 _ENV 就是 Application "PLBR"
	--
	-- 请重点注意，上下文仅仅是作为请求执行的容器，类似路由，
	-- 控制器等等实际处理都是归属于特定的Web App的，所以，
	-- 每个Http上下文对象都需要关联一个Web App，才能进行实际处理
	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}
end)

-- 保存PLBR到_G
import "PLBR"

-- 加载路由文件
require "plbr.route"
```

`Application`是由Web框架保存到`_G`的类，它继承了`System.Module`，所以可以作为环境使用，也提供了树状的代码管理机制（虽然很少需要这么使用）。在它里面，我们申明了`PLBR`命名空间，注意和Web App区分开来。之后定义了独属于这个Web App的Http上下文类，实际就是将它的对象和这个Web App进行绑定。

之后在`nginx.conf`文件的`content_by_lua`中，我们就是构建了这个上下文类的对象，然后调用`Process`方法启动请求的执行处理。这里的部分实际并不涉及具体的业务逻辑，因为根据请求url的不同，我们需要进行的处理都不相同，那么首先我们需要能根据url对请求进行分发，第一步，我们需要一个路由文件进行管理。

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	-- 所有属于PLBR这个Web App的配置，资源都需要定义在这个Web App环境中

	__Route__("/")
	__Text__() function hello(context)
		return "Hello world"
	end
end)
```

保存后，启动服务器(初次需要创建一个logs目录)

```shell
cd ~/www/
mkdir logs
cd ~
./start.sh
```

如果启动过，用`./reload.sh`。

然后可以打开浏览器，输入虚拟机地址(ip addr，VBOX的话，一般是192.168.56.xx)或你的服务器地址直接访问，或者CentOS中使用

```shell
curl http://localhost
```

就可以看到输出结果是`Hello world`。这样，我们的测试环境就正式可以使用了。可以看到，虽然之前做了很多铺垫，但实际业务逻辑相当简单。路由，输出方式和保存有业务逻辑的函数绑定，我们可以使用路由完成所有的Web API创建的工作，不过这只是基础部分，通常并不会将主要业务放在路由中直接处理，而是使用MVC中控制器来处理业务，稍后会看到详细的介绍。

后面单独列出Url地址时，会形如 `/test`，没有特殊说明请自行拼接为`http://localhost/test`，或指定的IP的形式`http://192.168.56.xx/test`。

### __Route__ 路由管理

用户通过url访问网站的不同区域和功能，为了将请求分发给对应的请求处理流程，我们需要进行路由管理，一个路由通常由两部分组成，首先是匹配请求url使用的路由字符串，可以是精确匹配用，也可以是作为模式字符串去匹配:

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/hello")
	__Text__() function hello(context)
		return "Hello world"
	end

	__Route__ ".*" __Text__()
	function parsetype(context)
		local target = context.Request.Url:gsub("/", "."):sub(2, -1) -- /System/Threading -> System.Threading
		local ns = Namespace.GetNamespace(target)

		if ns then
			return target .. " is " .. tostring(getmetatable(ns))
		else
			return target .. " isn't a type"
		end
	end
end)
```

请使用`./reload.sh`重启服务器查看结果，路由管理属于初始化的部分，并非动态加载，所以，我们需要重启服务器来查看修改。然后我们可以测试:

* GET /hello  - Hello world

* GET /HELLO  - Hello world

* GET /System/NoneExist - System.NoneExist isn't a type

* GET /System/Collections/List - System.Collections.List is class

这里使用了两种路由路径，第一种类似`/hello`，没有正则表达式，这类是静态路由，另一类是类似`.*`, `/test/*.lsp`这样具有模式字符串的动态路由。

当任意请求进入时，会先以大小写无视的规则去匹配静态路由，这个匹配实际是利用Lua的哈希表完成，所以，无论多少静态路由，都只有1到2次查询。如果匹配成功，就将请求交给对应的流程进行处理。

如果无法匹配静态路由，系统将根据动态路由的注册顺序，进行匹配，所以，上面定义的第二个路由虽然能匹配所有请求，但它不会被用于处理`/hello`的请求。

`__Route__`并不是只能用于绑定的路径，它实际的构造体函数是

```lua
__Route__(String, HttpMethod/HttpMethod.ALL, Boolean/true)
```

第一个参数是访问路径，第二个参数的类型是`HttpMethod`，这个枚举类型包含了所有的Http方法，详见[Web 常量](#Web-常量)，最后一个参数是路由是否无视大小写，默认是true，所有上面的`/HELLO`也会被`/hello`匹配。通常很少需要调整第三个参数，重点在于第二个:

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/test", HttpMethod.GET) __Text__()
	function getTest(context)
		return "GET TEST"
	end

	__Route__("/test", HttpMethod.POST) __Text__()
	function postTest(context)
		return "POST TEST"
	end
end)
```

这个测试适合用curl进行

```shell
curl http://localhost/test
curl http://localhost/test -X POST
```

测试可以得到两个不同的返回结果，这样同一个WEB API接口，我们可以组合`HttpMethod`来完成不同的操作。

路由本身并不处理请求，我们定义路由只是为了给一个Web APP生成一套路由，然后请求传给这个Web App后，路由管理器根据注册的路由将请求分发给各个处理流程。

上述的路由处理中，都伴随使用了`__Text__`特性，这个特性将函数封装为一个处理流程对象，这个函数的返回值将作为请求结果，按照`text/plain`输出。

下面详细介绍这些特性。


### `System.Web.__Text__`

如上面的例子所述，`__Text__`特性用于将函数封装为绑定给路由的请求处理流程对象，函数的返回值将以`text/plain`类型输出给客户端。除了上面例子中的简单模式外，也支持迭代器的形式，分多次输出文本给客户端：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)	
	__Route__("/multitext", HttpMethod.GET)
	__Text__(true) __Iterator__()
	function MultiText(context)
		coroutine.yield("This is part of the result\n")
		coroutine.yield("This is another part of the result\n")
	end
end)
```

注意，需要将true作为`__Text__`的构造参数来申明目标是一个迭代器，因为特性本身并没有机制去确认目标函数是否封装为了迭代器。重启服务器后，访问`GET /multitext`可以看到效果。两端文本都正常输出了。


### `System.Web.__Json__`

`__Json__`特性用于将函数封装为绑定给路由的请求处理流程对象，函数的返回值将以`application/json`的形式，序列化后传给客户端：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)	
	__Route__("/data")
	__Json__() function getData(context)
		local data = {}

		for k, v in pairs(_G) do
			if type(v) == "table" and getmetatable(v) == nil then
				local item = {}

				for j, l in pairs(v) do
					if type(l) == "function" then
						item[#item + 1] = j
					end
				end

				data[k] = item
			end
		end

		return data
	end
end)
```

访问`GET /data`可以看到结果，它将`_G`内所有值是table的键值对保存下来，然后将table内的包含的函数的名字都保存为一个数组，这点可以在显示结果中看到。


### `System.Web.__Redirect__`

`__Redirect__`特性用于根据返回值重定向url，

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/text")
	__Text__() function gettext(context)
		return "Hello"
	end

	__Route__("/redirect")
	__Redirect__() function redirect(context)
		return "/text"
	end
end)
```

之后使用浏览器访问`GET /redirect`即可看到地址栏被重定向了。（localhost记得改成IP地址）


### `System.Web.__View__`

`__View__`特性相对上面的特性较为复杂，它会同时注册一个视图模板或者模板文件，模板将会被生成为一个视图类，业务函数的处理结果将作为初始化表（如果提供）用于构造视图类的对象，之后视图类会渲染出网页内容提供给客户端：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/index")
	__View__ "index.view" [[
		<html>
			<head>
				<title>@self.title</title>
			</head>
			<body>
				<p>@self.welcome</p>
			</body>
		</html>
	]]
	function index(context)
		-- 上下文使用介绍稍后有更详细的说明
		local name = context.Request.QueryString.name

		return { title = "Hi " .. name, welcome = "Welcome here, " .. name }
	end
end)
```

访问`GET /index?name=Ann`结果为

```html
<html>
	<head>
		<title>Hi Ann</title>
	</head>
	<body>
		<p>Welcome here, Ann</p>
	</body>
</html>
```

`__View__`特性实际主要是用于绑定模板文件，模板文件都有类似`.view`这样的后缀名，这种文件都是[资源文件](017.io.resource.md)，根据后缀，系统会使用不同的资源加载器去加载这些文件，这也是为什么上面的例子中，除了HTML模板，还需要提供一个文件名，这个文件名的名字将作为生成的视图类的类名，而后缀名决定了系统如何加载这份模板。

`.view`文件的具体加载规则稍后详细介绍，现在先集中在`__View__`这个特性上。通常来说，路由文件的修改需要重启服务器，但资源文件当开启Debug模式时，是可以随时修改查看修改效果的。我们将上面的例子修改为


```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/index")
	__View__ "/view/index.view"
	function index(context)
		-- 上下文使用介绍稍后有更详细的说明
		local name = context.Request.QueryString.name

		return { title = "Hi " .. name, welcome = "Welcome here, " .. name }
	end
end)
```

注意，因为这里需要指定文件路径，请务必使用绝对路径，通常我们的资源文件有多种，最好通过目录分开，所以，这里给了一个`view`目录。

另外请注意nginx.conf中设置了root为html目录，我们的资源文件也是以/html目录为根目录，所以，实际视图模板需要保存在`~/www/html/view/index.view`目录下，后面的资源文件类似，省略掉`~/www`部分。

然后创建第一个视图模板文件:

```html
<!-- /html/view/index.view -->
<html>
	<head>
		<title>@self.title</title>
	</head>
	<body>
		<p>@self.welcome</p>
	</body>
</html>
```

首先重启服务器后，再次访问`GET /index?name=Ann`，一切正常后，修改这个模板文件为:

```html
<!-- /html/view/index.view -->
<html>
	<head>
		<title>@self.title</title>
	</head>
	<body>
		<p>A modify version</p>
		<p>@self.welcome</p>
	</body>
</html>
```

刷新页面，可以看到输出结果已经改变了。类似视图模板文件这样的资源文件都是可以在开发中随时修改，随时看到效果的。

虽然因为我们现在的业务逻辑保存在路由文件中，导致修改业务需要重启服务器，但后面引入的MVC框架会彻底解决这些问题。包括目前每个函数处理结果的返回方式固定的问题，在MVC中都会被很好的解决掉。

回到`__View__`特性，我们并不需要在申明这个特性时，指定模板文件，如果不指定模板文件，那么它会将函数的第一个返回值作为模板路径，第二个值作为构造模板对应视图类的初始表：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/index")
	__View__() function index(context)
		if tonumber(context.Request.QueryString.ver) == 1 then
			return "/view/index_v1.view"
		else
			return "/view/index.view"
		end
	end
end)
```

```html
<!-- /html/view/index.view -->
<html>
	<head>
		<title>Test web Current</title>
	</head>
	<body>
	</body>
</html>
```

```html
<!-- /html/view/index_v1.view -->
<html>
	<head>
		<title>Test web V1</title>
	</head>
	<body>
	</body>
</html>
```

访问`/index?ver=1`和`/index`可以看到不同的结果。通常`.view`是作为MVC中的View部分使用。稍后我们会来看它的详细使用规则。虽然框架限定了`.view`文件的渲染规则，但系统允许自定义渲染引擎实现其他规则。这点，在最后介绍。


### Application的定义

下面是`System.Web.Application`类申明的资源:

静态属性             |类型                                |描述
:-------------------|:-----------------------------------|:---------------
ConfigSection       |System.Configuration.ConfigSection  |只读，提供了Web App的配置定义，详见[配置系统](014.configuration.md)


属性                 |类型                       |描述
:-------------------|:--------------------------|:---------------
_Application        |System.Web.Application     |获取根Web app，因为继承自`System.Module`，所以，可以实现树状的代码管理，这就需要能定位根Web App，所以路由，控制器等资源都仅注册在根Web App
_Config             |Table                      |设置配置，使用上面定义的`ConfigSection`配置定义来解析，稍后介绍
_Root               |String                     |读写Web App访问Url的根路径，通常是空，Web App就可以匹配所有请求的Url，如果设置为`/test`，那么仅能匹配`/test/*`的url，也就是作为子网站使用
_ErrorHandler       |Function                   |错误处理函数，请求时代码执行发生的错误，会被传入这个函数，通常可以考虑直接输出到客户端（便于Debug）或者是错误日志


函数                |参数                        |返回                      |描述
:-------------------|:--------------------------|:-------------------------|:--------------------
Url2Path            |url                        |path                      |将Url请求地址转为对应该Web App的地址（即移除子网站根路径）
Path2Url            |path                       |url                       |将Web App的指定地址转为Url请求地址（即拼接子网站根路径）

这两个方法通常由系统内部使用，但`Path2Url`可能需要被用到视图中，转换特定的地址，稍后的例子中可以看到。


#### Web App作为子网站

在`/conf/init.lua`中我们使用`Web.Config`配置整个框架的行为，同样，我们可以对Web App进行配置，重点是配置`Root`，这样可以在一个nginx服务器上运行多个Web App，每个对应一个子网站:

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}
end)

import "PLBR"

require "plbr.route"

-- 配置文件在最后加载，这样可以在之前添加的新的配置定义（例如数据库连接，稍后演示）
require "plbr.config"
```

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
	_Config = {
		-- 子网站根路径
		Root            = "/sub",

		-- 默认导出给视图模板文件的函数
		-- 视图中可以直接使用export里面定义的函数
		View            = {
			Default     = {
				export   = {
					Url = function (path) return _ENV:Path2Url(path) end,
				}
			}
		},
	}
end)
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/text")
	__Text__() function hello(context)
		return "hello world"
	end

	__Route__("/redirect")
	__Redirect__() function redirect(context)
		return "/text"
	end

	__Route__("/index")
	__View__[[/view/index.view]]
	function index() end
end)
```

```html
<!-- /html/view/index.view -->
<html>
	<head>
		<title>Test web</title>
	</head>
	<body>
		<a href="@Url('/text')">test url</a>
	</body>
</html>
```

重启服务器后，可以访问 `GET /sub/text`和`GET /sub/redirect`获取结果，可以看到这个Web App运行在`/sub`子网站中了。可以看到，我们的路由和重定向都无需处理`/sub`这部分地址。这样，通过调整`config.lua`文件，我们可以随意的调整子网站路径，不会影响Web App的执行。

访问`Get /sub/index`可以看到结果如

```html
<!-- /html/view/index.view -->
<html>
	<head>
		<title>Test web</title>
	</head>
	<body>
		<a href="/sub/text">test url</a>
	</body>
</html>
```

可见子网站的路径也会正常拼接上去，注意给定的地址必须是`/`开始，也就是绝对路径，处理会忽略相对路径。因为系统并没有办法判定哪些是url地址，哪些url地址需要附着子网站根路径，所以，这个操作需要自行完成，关于配置中`View`的使用，将在后面详细介绍。这里了解`export`的用法即可。

因此，我们可以定义多个Web App，然后对应到不同的`Root`地址，这就实现了一个nginx服务器多个Web App的运行。这点本文档就不具体给出例子，参照之前的例子即可。


#### Web App的错误处理

除了`Root`，Web App还可以配置一个`ErrorHandler`(对应`_ErrorHandler`属性)，用于绑定错误处理。通常我们会考虑将错误输出到客户端（开发期）或者日志中（运营期），不过在[Openresty][]中，Lua错误会自动记录到日志，仅需要用`error`抛出即可，所以，我们的例子是输出到客户端的形式:

``` lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
	_Config = {
		ErrorHandler = function(err, stack, context)
			context.Response.Write(err)
			context.Response:Close()
		end,
	}
end)
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/index")
	__View__[[/view/index.view]]
	function index(context) end
end)
```

```html
<!-- /html/view/index.view -->
<html>
	<head>
		<title>Test web</title>
	</head>
	<body>
		<p>@self.Data.NoExist</p>
	</body>
</html>
```

然后访问`GET /index`，会得到错误: `/root/www/html/view/index.view:7: attempt to index field 'Data' (a nil value)`，可见哪怕是视图，错误也可以被正确定位到。当然，实际使用的错误处理会相对复杂些，比如有专门的错误处理页面。

它的参数形式是为了符合`error`，第一个是错误信息，第二个是调用堆栈级别，第三个是上下文对象，这个会被`error`忽略，但我们其他的情况可以使用。


## Web 常量

下面是`System.Web`下面定义的枚举类型：

```lua
-- HTTP方法
__Flags__() __Sealed__() __Default__"GET"
enum "HttpMethod" {
	ALL                 = 0,
	"OPTIONS",
	"GET",
	"HEAD",
	"POST",
	"PUT",
	"DELETE",
	"TRACE",
	"CONNECT",
}

--- HTTP处理结果
__Sealed__() __Default__ "OK"
enum "HTTP_STATUS" {
	CONTINUE            = 100,  --请求可以继续。
	SWITCH_PROTOCOLS    = 101,  --服务器在升级头中交换了协议。
	OK                  = 200,  --请求成功完成。
	CREATED             = 201,  --请求已完成并导致创建新资源。
	ACCEPTED            = 202,  --已接受请求进行处理，但处理尚未完成。
	PARTIAL             = 203,  --实体报头中返回的元信息不是来自始发服务器的可确定集合。
	NO_CONTENT          = 204,  --服务器已完成请求，但没有新信息要发送回。
	RESET_CONTENT       = 205,  --请求已完成，客户端程序应重置导致发送请求的文档视图，以允许用户轻松启动另一个输入操作。
	PARTIAL_CONTENT     = 206,  --服务器完成了对资源的部分获取请求。
	WEBDAV_MULTI_STATUS = 207,  --这表示单个响应有多个状态代码。响应体包含描述状态代码的可扩展标记语言（XML）。有关详细信息，请参见http扩展以进行分布式创作。
	AMBIGUOUS           = 300,  --请求的资源在一个或多个位置可用。
	MOVED               = 301,  --已将请求的资源分配给新的永久统一资源标识符（uri），以后对该资源的任何引用都应使用返回的uri之一完成。
	REDIRECT            = 302,  --请求的资源暂时位于另一个uri下。
	REDIRECT_METHOD     = 303,  --对请求的响应可以在不同的uri下找到，应该使用该资源上的get http动词来检索。
	NOT_MODIFIED        = 304,  --请求的资源未被修改。
	USE_PROXY           = 305,  --必须通过位置字段提供的代理访问请求的资源。
	REDIRECT_KEEP_VERB  = 307,  --重定向请求保持相同的HTTP动词http/1.1行为。
	BAD_REQUEST         = 400,  --由于无效语法，服务器无法处理该请求。
	DENIED              = 401,  --请求的资源需要用户身份验证。
	PAYMENT_REQ         = 402,  --未在http协议中实现。
	FORBIDDEN           = 403,  --服务器理解请求，但无法完成它。
	NOT_FOUND           = 404,  --服务器未找到与请求的URI匹配的任何内容。
	BAD_METHOD          = 405,  --不允许使用http动词。
	NONE_ACCEPTABLE     = 406,  --未找到客户可接受的响应。
	PROXY_AUTH_REQ      = 407,  --需要代理身份验证。
	REQUEST_TIMEOUT     = 408,  --服务器等待请求超时。
	CONFLICT            = 409,  --由于与资源的当前状态冲突，无法完成请求用户应重新提交更多信息。
	GONE                = 410,  --请求的资源在服务器上不再可用，并且不知道转发地址。
	LENGTH_REQUIRED     = 411,  --如果没有定义的内容长度，服务器无法接受请求。
	PRECOND_FAILED      = 412,  --在服务器上测试时，一个或多个请求头字段中给定的前置条件计算为false。
	REQUEST_TOO_LARGE   = 413,  --服务器无法处理该请求，因为请求实体大于服务器能够处理的范围。
	URI_TOO_LONG        = 414,  --服务器无法为请求提供服务，因为请求uri的长度超过了服务器可以解释的长度。
	UNSUPPORTED_MEDIA   = 415,  --服务器无法为请求提供服务，因为请求实体的格式不受请求方法的请求资源支持。
	RETRY_WITH          = 449,  --执行相应操作后应重试请求。
	SERVER_ERROR        = 500,  --服务器遇到意外情况，无法满足请求。
	NOT_SUPPORTED       = 501,  --服务器不支持完成请求所需的功能。
	BAD_GATEWAY         = 502,  --服务器在充当网关或代理时，从试图完成请求时访问的上游服务器接收到无效响应。
	SERVICE_UNAVAIL     = 503,  --服务暂时过载。
	GATEWAY_TIMEOUT     = 504,  --请求在等待网关时超时。
	VERSION_NOT_SUP     = 505,  --服务器不支持请求消息中使用的HTTP协议版本。
}
```

普通网站开发中，通常只需要在路由绑定时使用`HttpMethod`。


## 编码和解码

`System.Web`提供了4个常用的解码和编码方法：

方法               |参数                                                                  |描述
:------------------|:--------------------------------------------------------------------|:------------------------------
HtmlEncode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |将字符串编码，以便在浏览器中显示
HtmlDecode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |解码字符串
UrlEncode          |text:String                                                          |对Url进行编码
UrlDecode          |text:String                                                          |对Url进行解码


用例类似：

```lua
require "PLoop.System.Web"

PLoop(function(_ENV)
	-- 注意，System.Web也是公共命名空间，所以，可以直接调用这些方法
	local str = HtmlEncode("<test>")
	print(str)               -- &lt;test&gt;
	print(HtmlDecode(str))   -- <test>

	str       = UrlEncode("/test?x=123")
	print(str)               -- %2Ftest%3Fx%3D123
	print(UrlDecode(str))    -- /test?x=123
end)
```


## 上下文 - System.Web.HttpContext

在上面的例子中，所有流程处理函数都有一个context作为第一个参数，这个值是`System.Web.HttpContext`类的对象，也就是Http上下文对象。结合`nginx.conf`中的`content_by_lua`处理，每个Http请求都会构建一个Http上下文对象，然后调用它的`Process`方法启动处理流程。

每个Http上下文对象都会有绑定唯一一个Web App，它会检查注册在这个Web App的所有路由，匹配后，执行对应的流程，然后返回结果给客户端。所以，Http上下文管理了整个Http请求的过程，同时也是处理过程中，共享数据的保存位置，上下文对象的存在，可以有效的避免共享数据导致的系统线程冲突问题。

所以，我们会看到这个上下文对象存在于Web框架的每个角落。对于绑定给路由的流程处理函数来说，它们可以从上下文中读取Http请求提交的信息，也能通过上下文将结果输出给客户端。

`System.Web.HttpContext`实际是抽象的，上面我们自己定义上下文类是继承自`NgxLua.HttpContext`，它继承了`System.Web.HttpContext`提供了针对[Openresty][]的实现。

`System.Web.HttpContext`申明了上下文类的定义：

抽象属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Request                     |System.Web.HttpRequest            |提供所有Http请求的信息，需要针对特定平台实现
Response                    |System.Web.HttpResponse           |用于向客户端输出处理结果，需要针对特定平台实现
SessionType                 |- System.Web.HttpSession          |用于生成用户会话对象的类，有默认实现，可根据业务自行扩展

----------------------------

最终属性（无法被覆盖）        |类型                                         |描述
:---------------------------|:--------------------------------------------|:-------------------------
Application                 |System.Web.Application                       |上下文对象所属的Web App，它具有独立的路由，控制器和其他资源
ProcessPhase                |System.Web.IHttpContextHandler.ProcessPhase  |当前请求处理的阶段，稍后介绍
Session                     |System.Web.HttpSession                       |获取用户会话对象，可用于保存会话数据
IsInnerRequest              |Boolean                                      |该上下文是否用于处理内部请求，为了分离业务逻辑，我们可以考虑用内部请求url的形式替代直接的对象调用，那么就需要能确认是否是内部请求，比如内部请求不需要验证用户权限等等

----------------------------

方法                        |参数                                                         |返回                        |描述
:---------------------------|:-----------------------------------------------------------|:---------------------------|:--------------------------------
Process                     |                                                            |无                          |启动请求处理的流程，这用于`content_by_lua`是本Web框架Http请求的入口
ProcessInnerRequest         |url: String, params: Table/nil, HttpMethod/nil              |status: HTTP_STATUS, result |启动一个内部请求，需要指定url，请求表单和Http方法

`ProcessInnerRequest`用于发起一个内部请求，内部请求的结果将返回两个值，第一个是处理的Http状态，另一个结果通常是使用`__Json__`输出的JSON数据，但因为是内部请求，输出数据不会被序列化，而是直接返回，这有助于返回数据库处理的结果集。避免过度序列化和反序列化操作。



### 请求 - System.Web.HttpRequest

`System.Web.HttpRequest`申明了包含所有Http请求信息的对象，实现可以参考[NgxLua][]的`NgxLua.HttpRequest`。

这个类申明了下面的属性：

抽象属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
ContentLength               |Number                            |请求的内容长度
ContentType                 |String                            |请求的MIME类型
Cookies                     |Table                             |获取客户端请求的Cookie集合
Form                        |Table                             |获取客户端提交的表单(非GET操作)
HttpMethod                  |HttpMethod                        |获取Http请求方法
IsSecureConnection          |Boolean                           |请求是否使用了HTTPS
QueryString                 |Table                             |获取客户端提交的请求数据(GET /xx?v=1&b=2)
RawUrl                      |String                            |获取原始请求字符串
Root                        |String                            |获取请求对应的根目录，对我们的例子即`~/www/html`
Url                         |String                            |获取请求的url

其中Cookies，Form，QueryString都需要返回字典table包含提交的键值对。


最终属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |请求对象所属的上下文对象
Handled                     |Boolean                           |该请求是否已经被处理了，稍后解释


### 响应 - System.Web.HttpResponse

`System.Web.HttpResponse`类申明了输出结果给客户端的对象，实现可以参考[NgxLua][]的`NgxLua.HttpResponse`。

这个类申明了以下的属性和方法：

抽象属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
ContentType                 |String                            |读写输出的MIME类型，类似`__Text__`使用`text/plain`
RedirectLocation            |String                            |读写重定向的url
RequestRedirected           |Boolean                           |请求是否已经被重定向
Write                       |Function|System.IO.TextWriter     |读写输出结果的函数或对象
StatusCode                  |HTTP_STATUS                       |读写处理结果的状态
Cookies                     |System.Web.HttpCookies            |输出一组Cookie

响应对象的`Write`属性可能是，函数，也可以使用流输出对象，所以，它定义成属性，而不是方法。使用类似

```lua
context.ContentType = "text/plain"
context.Write("Hello world")
```


最终属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |响应对象所属的上下文对象


抽象方法                     |参数                              |描述
:---------------------------|:---------------------------------|:-------------------------
SendHeaders                 |                                  |发送响应头
Close                       |                                  |关闭响应，结束输出
ServerRedirect              |                                  |发送重定向响应
------------------------------------------------------------------------------------------

这三个方法都没有额外参数，所需的参数都可以通过响应对象获取到，例如重定向的地址。


方法                        |参数                                                                      |描述
:---------------------------|:------------------------------------------------------------------------|:-------------------------
Redirect                    |url: String, code: HTTP_STATUS/HTTP_STATUS.REDIRECT, raw: Boolean/false  |重定向到指定的地址，注意第三个参数raw，因为Web App可能只对应一个子网站，那么实际地址需要拼接子网站的根路径，如果希望不拼接，第三个参数需要传入true


### Cookie管理 - System.Web.HttpCookie & System.Web.HttpCookies

请求对象的`Cookies`仅仅是保存客户端提交的键值对的哈希表，使用起来类似:

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function test(context)
	return {
		User = { Name = context.Request.Cookies["name"] }
	}
end
```

响应对象的Cookie相对比较复杂，它的`Cookies`属性虽然是抽象的，但是已经有了一个默认实现，读取它时，会自动创建一个`System.Web.HttpCookies`类的对象，这是一个集合类，它的元素是`System.Web.HttpCookie`类的对象。

`HttpCookie`对象不需要自己创建，可以直接使用指定cookie名作为`HttpCookies`对象的字段访问，一个自动被创建的`HttpCookie`对象将会被返回，我们可以为它设置值和超时等等:

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function writecookie(context)
	context.Response.Cookies["ID"].Value = "TestUser1234"
	return {}
end
```

下面是`HttpCookie`具有的属性:

属性                        |类型                                  |描述
:---------------------------|:------------------------------------|:-------------------------
Domain                      |String                               |获取或设置要与cookie关联的域
Expires                     |Date                                 |获取或设置cookie的到期日期和时间。
MaxAge                      |Number                               |获取或设置cookie的最大使用期限。
HasKeys                     |Boolean                              |获取一个值，该值指示cookie是否具有子键。
HttpOnly                    |Boolean                              |获取或设置一个值，该值指定客户端脚本是否可以访问cookie。
SameSite                    |System.Web.HttpCookie.SameSiteValue  |获取或设置是否应将cookie限制为第一方或同一站点上下文
Name                        |String                               |获取或设置cookie的名称。
Path                        |String                               |获取或设置要用当前cookie传输的虚拟路径。
Secure                      |Boolean                              |获取或设置一个值，该值指示是否使用安全套接字层（SSL）传输cookie，即仅通过https。
Value                       |String                               |获取或设置单个cookie值。
Values                      |Table                                |获取包含在单个cookie对象中的键/值对的集合。

其中SameSiteValue的定义是

```lua

__Sealed__() enum "SameSiteValue" {
	Strict = "Strict",  -- 禁止第三方Cookie，跨站点时，该Cookie不会被发送
	Lax    = "Lax",     -- 禁止第三方Cookie，跨站点时，一般该Cookie不会被发送，但GET请求时可以例外
}
```

我们可以用`Date`类型为到期时间赋值：

```lua
context.Response.Cookies["ID"].Expires = System.Date.Now:AddDays(30)
```

也可以为Cookie添加子项：

```lua
context.Response.Cookies["ID"].Values["Age"] = 33
context.Response.Cookies["ID"].Values["Gender"] = "male"
```

`Cookies`属性是延迟加载的，仅当使用时通过默认值构造工厂创建，这点对其他对象属性也是一样的，可以有效的降低消耗。


### 用户会话 - System.Web.HttpSession

Http本身的机制下，每次的请求都是独立的，为了能跟踪特定的客户端和用户，我们通常需要采用多种方式来确定，但不管客户端采用何种方式，服务器端一般都采用用户会话的方式。

一般通过上下文对象的`Session`属性获取用户会话对象，对于特定的客户端，用户会话对象会有唯一的ID用于标识。默认用户会话对象是`System.Web.HttpSession`类的对象，但可以继承定制自己的会话类，然后作为Web App的特定上下文类的`SessionType`即可。

下面是会话对象的属性申明：

最终属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |用户会话所属的上下文对象
Items                       |                                  |一个索引器属性，用于读写键值对，虽然并没有限定，但最好键采用字符串，值采用可序列化的值，便于使用任意的存储方式
SessionID                   |String                            |获取用户会话的唯一ID
Timeout                     |Date                              |读写超时时间
TimeoutChanged              |Boolean                           |超时时间是否修改过
Canceled                    |Boolean                           |该用户会话是否取消，下次用户访问时，会使用新的ID
IsNewSession                |Boolean                           |该用户会话是否是新生成的会话，或者超时时间被修改，此时，需要将新会话ID输出到客户端（通常是通过Cookie)
ItemsChanged                |Boolean                           |会话保存的键值对是否有修改，如果有修改，需要将这些修改保存到会话数据存储位置


上述属性中，通常业务部分只使用`Items`，其他属性由框架管理：

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function test(context)
	context.Session.Items.user = "TestUser1234"
	return {}
end
```

注意，`Items`无法跟踪多级修改，例如

```lua
context.Session.Items.UserList[1003] = { name = "king" }
```

通常这种情况，需要替换`UserList`：

```lua
local userList = System.Toolset.clone(context.Session.Items.UserList) or {}
userList[1003] = { name = "king" }
context.Session.Items.UserList = userList
```

`Session`的使用相对比较简单，只需要通过`Items`读写会话变量即可。而底层的问题在于，用何种方式将会话的唯一ID和超时等信息保存到客户端，以及如何保存用户会话变量。

通常这两个部分是通过两个作为管理器的对象完成处理，系统申明了两个接口分别对应这两部分处理。


#### System.Web.ISessionIDManager

`ISessionIDManager`申明了对会话ID的管理功能，包含新建，读取，保存，验证几个部分。

它声明了以下的抽象方法：

抽象方法                     |参数                                       |描述
:---------------------------|:------------------------------------------|:-------------------------
GetSessionID                |context: HttpContext                       |从上下文对象中读取会话的唯一ID
CreateSessionID             |context: HttpContext                       |为上下文对象新建一个唯一ID
RemoveSessionID             |context: HttpContext                       |删除该上下文对象的当前会话ID
SaveSessionID               |context: HttpContext, session: HttpSession |为上下文对象保存会话，即保存会话的唯一ID到客户端
ValidateSessionID           |id: String                                 |验证会话ID

通常我们会将会话ID以Cookie的形式保存在客户端中，这是比较简单也推荐的方式。我们来看它的两个实现：


##### System.Web.GuidSessionIDManager

这个实现使用`System.Guid`结构体的值作为会话ID，并且将它保存到指定的Cookie中，配合超时设定来管理会话ID的生存时间。

那么，我们可以调整之前的代码文件:

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}

	-- 会话ID管理器
	GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/session")
	__Text__() function init(context)
		return context.Session.SessionID
	end
end)
```

多次访问`GET /session`可以看到会话ID唯一。


##### NgxLua.JWTSessionIDManager

这个会话ID管理器的设计基于[Json Web Token](https://jwt.io/)，它依赖于[resty.jwt](https://github.com/SkyLothar/lua-resty-jwt)，可以使用如下命令安装依赖

```shell
cd /usr/local/openresty/lualib/resty
wget https://raw.githubusercontent.com/jkeys089/lua-resty-hmac/master/lib/resty/hmac.lua
wget https://raw.githubusercontent.com/SkyLothar/lua-resty-jwt/master/lib/resty/jwt.lua
wget https://raw.githubusercontent.com/SkyLothar/lua-resty-jwt/master/lib/resty/jwt-validators.lua
wget https://raw.githubusercontent.com/SkyLothar/lua-resty-jwt/master/lib/resty/evp.lua
```

也可以自行安装。安装后，将上面例子中的init文件修改为

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}

	-- 会话ID管理器
	NgxLua.JWTSessionIDManager{ CookieName = "PLBR_JWT", TimeoutMinutes = 1 * 24 * 60, SecretKey = System.Guid.New():gsub("-", ""), HashAlgorithm = "HS256", Application = _ENV }

	-- 会话存储管理器
	NgxLua.JWTSessionStorageProvider{ Application = _ENV }
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/session")
	__Text__() function init(context)
		context.Session.Items["User"] = "Ann"
		return "请查看Cookie"
	end
end)
```

JWT设计上，会话ID和会话变量都会加密后保存在Cookie中，所以，我们需要同时提供配套的会话变量存储管理器。定义JWT会话ID管理器时，除了常规的Cookie名，超时分钟数外，还需要指定密钥和哈希算法，通常不输出时，默认值，就是例子中我们提供给`SecretKey`和`HashAlgorithm`的值，所以，通常也不需要提供（每次重启服务器后，会话ID都会失效，如果固定SecretKey则不会失效）。

保存后，重启服务器，然后访问`Get /session`，再F12打开调试器，查看Cookie，可以找到类似

```JS
PLBR_JWT:  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VyIjoiQW5uIiwiX3RpbWVvdXQiOjE1NzI4ODEyNDd9._fqPPE_dL2lNV8SQUSI2OlnxdJBtedt1xzUrULwAJQg
```

注意，JWT的机制比较特别，需要写入会话变量后（通常是用户标识），才会被保存到客户端。这个机制有个好处在于，会话变量保存在客户端，服务器端不需要保存任何会话数据，那么多服务器处理请求时，就不需要考虑如何共享会话数据这个问题。


#### System.Web.ISessionStorageProvider

`ISessionStorageProvider`接口申明了如何实现会话变量存储，它申明了以下的抽象方法：

抽象方法                     |参数                                       |描述
:---------------------------|:------------------------------------------|:-------------------------
Contains                    |id: String                                 |指定的会话ID是否有会话变量保存在存储中
GetItems                    |id: String                                 |返回指定会话ID的会话变量
RemoveItems                 |id: String                                 |清空指定会话ID的会话变量
SetItems                    |id: String, item: Table, timeout: Date/nil |更新指定会话ID的会话变量，可以指定超时
ResetItems                  |id: String, timeout: Date                  |更新指定会话ID的会话变量的超时
TrySetItems                 |id: String, item: Table, timeout: Date/nil |尝试将会话变量写入不存在于存储的会话ID，如果成功，返回true


系统提供了四种实现。


##### System.Web.TableSessionStorageProvider

这是直接用Lua的table作为存储，因为它不是线程安全的，仅用于普通测试。

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}

	-- 会话ID管理器
	GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
	TableSessionStorageProvider(_ENV)
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
	__Route__("/session")
	__Text__() function init(context)
		context.Session.Items["ViewCount"] = (context.Session.Items["ViewCount"] or 0) + 1
		return "View Count: " .. context.Session.Items["ViewCount"]
	end
end)
```

访问`GET /session`可以看到View Count会被正确计数。


##### NgxLua.ShareSessionStorageProvider

这个存储是借用了[Openresty][]的共享字典，它是线程安全的，但限于容量，并不适合大规模使用，仅使用小型网站，请注意`plbr_session_storage`是在`nginx.conf`文件中申明的。


```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}

	-- 会话ID管理器
	GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
	ShareSessionStorageProvider("plbr_session_storage", _ENV)
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

访问`GET /session`可以看到View Count会被正确计数。



##### NgxLua.RedisSessionStorageProvider

这个存储依赖于[resty.redis](https://github.com/openresty/lua-resty-redis)，通常[Openresty][]随附安装，但如果加载失败，请自行安装。它使用Redis服务器保存会话变量。

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
	namespace "PLBR"

	class "HttpContext" {
		NgxLua.HttpContext,
		__ctor = function(self) self.Application = _ENV end
	}

	-- 会话ID管理器
	GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
	NgxLua.RedisSessionStorageProvider({ host = "127.0.0.1", port = 6379 }, _ENV)
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

访问`GET /session`可以看到View Count会被正确计数。这个适合中型网站，但用户规模很大时，对服务器始终是一定的负担。


##### NgxLua.JWTSessionStorageProvider

这个存储是配合`JWTSessionIDManager`使用，将会话变量存储在客户端中，可以很大的减轻服务器负担，而且加密的保存方式，也可以杜绝客户端任意修改它们。

但因为保存的变量是可以被解读的，所以，不能用于保存敏感信息。


## 页面渲染

### Lua Server Page (.lsp)

Normally we should use the MVC framework instead of the lua server page, but it's a good start for the page rendering.

To create a simple html page like:

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>PLoop.System.Web Test Page</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
	</head>
	<body>
		<p>
			This is the first PLoop.System.Web test page.
		</p>
	</body>
</html>
```

Just copy the content to a .lsp file (like index.lsp). The lsp file contains the html and lua code and will be converted to a page class, then it would be used to handle the http request and generate the response.

The **PLoop** only provided one special page render engine **System.Web.PageRenderEngine**, so all template files will follow the same rules. We'll see how to create another page render engine at the last.


### Master Page (.master)

When you need to apply the same layout for several lsp files, it's best to create a master page that incldue the most common parts.

A master page file is ended with ".master". We can create a "mymaster.master" with the content :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>@{title My web site}</title>
		@{jspart <!-- javascript placeholder -->}
	</head>
	<body>
		@{body}
	</body>
</html>
```

The render engine use *@* as the directive, it means an instruction here to be executed.

The `@{title My web site}` is used to declare a **web part** that would be replaced by child page classes, *title* is it's name, the rest are default text, if the web part is not defined in the child page, the default text would be used.

Then the *index.lsp* :

```HTML
@{ master = "mymaster.master" }

@title{
	PLoop.System.Web Test Page
}

@body{
	<p>
		This is the first PLoop.System.Web test page.
	</p>
}
```

There is a special rule for all template files(no matter if it use another custom page render engine), if the first line of the file contains a lua table, it would be parsed as the page's configuration.

In here the *master* means the page class's super class, the *index.lsp* can also be used as another lsp file's master page, so the web part can be declared in both master page and the lua server page. Since the *index.lsp* inherited the *mymaster.master*, the *index.lsp* only need to define the web parts.

To implement a web part, the `@name{` and `}` must be on each line's head, and the content must have an indent(tab or space) for each line, so the render engine will know the begin and the end of it.

Beware, you must keep using the same indent style for one files (only use tab or only use space, and keep the start and end part with same indents).

If the page don't provide a web part, it would be leave empty or use the web part's default value. So if it don't give the *title* part, the output content should be `<title>My web site</title>`.

The output result of *index.lsp* would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>PLoop.System.Web Test Page</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<p>
			This is the first PLoop.System.Web test page.
		</p>
	</body>
</html>
```

### Super web part

We can override the master page's web part, but we also may need to show the contents come from the master page, we could use `@{super:body}` to generate the *body* web part designed in its master pages(or other super pages):

```html
@{ master = "index.lsp" }


@body{
	@{super:body}
	<p>
		This is the a PLoop.System.Web test page.
	</p>
}
```


### Mix HTML with lua

To embed Lua into html, there are four ways within the default page render engine :

#### Block

Used to define pure lua functions, also can be used to define the page class's method and other features :

```lua
@{
	local function rollDice(num, max, add)
		local sum = add

		for i = 1, num do
			sum = sum + math.random(max)
		end

		return sum
	end
}
```

Define a block of lua code is like defining a web part without name, it would be pure lua code in the block, if the function is not defined as local, it would be a class-method of the page class. The function and any variables defined in it can be used by anywhere that below the block.


#### Inline

Used to print an expression value, if the expression is not clear, the expression should be enclosed in parentheses, if use `@\`, the value would be encoded (or in the page configuration, use `encode=true` to force encoding all inline expressions) :

```html
@body{
	<p>Roll a dice(5d6+3) : @rollDice(5, 6, 3) </p>
	<p>encode test : @\"<test/>" </p>
}
```
The output should be like

```html
	<p>Roll a dice(5d6+3) : 22</p>
	<p>encode test : &lt;test/&gt; </p>
```

Things like `@a`, `@b`, `@(a+b)`, `@rollDice(5, 6, 3)` are inline codes, an inline code should be an expression that return a value, the value would be converted to a string to be displayed.

For the `a + b` expression, `@a + b` would confuse the system, it will treate the `@a` is a inline code, and the `+ b` is normal text, you should use parentheses around it.

The system can realize complex expression like `@King.Parent:Greet( Person{ Name = "Ann" } )`, also can realize string word like `@'test'`, `@"test"` or `@[=[test]=]`.

The table data returned by the expression will be serialized to JSON format string, so you can use it directly in javascript section like

```html
<script type="text/javascript">
	var data = @List(10):Map("x=>x^2"):ToList();
</script>
```

The result would be

```html
<script type="text/javascript">
	var data = [1,4,9,16,25,36,49,64,81,100];
</script>
```


#### Full-line

Normally used to generate the control structure to control how the content would be generated, use '@>' to mark the full line is lua code, if the first word of the line is a keyword like 'local', 'if', 'for', you can only use '@' at the start of the line, and `@--` would be used for full line comments :

```html
@body{
	@ local a, b = math.random(100), math.random(100)
	<p>@a + @b = @(a+b)</p>

	<p>Roll a dice(5d6+3) : @rollDice(5, 6, 3) </p>

	<p>
	@ local hour = Date.Now.Hour
	@ if hour < 11 then
		Good morning
	@ elseif hour > 20 then
		Good night
	@ end
	</p>
}
```

The *body* web part will be converted to one function, so you can declare any local variables and use any structures like `if-then-end`, `while-do-end`, `for-end`.  The control structures must be full-line.

The result should be

```html
	<p>81 + 87 = 168</p>

	<p>Roll a dice(5d6+3) : 24 </p>

	<p>
		Good night
	</p>
```


#### Mixed Method

If we take the web part implementation as function with zero-argument. We also can define function with arguments, it's called mixed method :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}
```

Here we defined a local method *appendVerSfx*, and then defined a mixed method to use it. The mixed method is used to generate javascript elements with name and version arguments.

Here is how to use it :

```html
@{ master = "mymaster.master" }

@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}
```

It's just like how to declare web parts, but there are a big different between them, when using mixed methods, the mixed method's definition are already know, when declare the web parts, their definition are unknow.

The result would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript" src="/js/index.js?v=3"></script>
	</head>
	<body>

	</body>
</html>
```

The lua blocks can also be used in a web part or mixed method like :

```html
@body{
	<p>
		@ {
			local hour, msg = tonumber(os.date():match("(%d+):"))
			if hour < 10 then
				msg = "Good morning"
			elseif hour > 20 then
				msg = "Good night"
			else
				msg = "Have a nice day"
			end
		}
		@msg
	</p>
}
```

Beware of the indents, the render engine don't do a semantic analysis for the code(but it'd help you to indicate the bugs), so it won't know where the block stoped if the indents don't match. The output should be :

```html
<p>
	Good night
</p>
```


### Helper Page (.helper)

The mixed methods are generaly used as help methods, so it's better to store them in one file, those files are helper pages. Unlike other type pages, the helper page would be converted to an interface, so it can be used by any other page classes.

We can set the helper to master page directly, so all the lua server pages that inherit it can use those mixed methods.

With the *globalhelper.helper* :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}
```

Re-write the *mymaster.master* :

```html
@{ helper = "globalhelper.helper" }

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>@{title My web site}</title>
		@{jspart <!-- javascript placeholder -->}
	</head>
	<body>
		@{body}
	</body>
</html>
```

So the *index.lsp* :

```html
@{ master = "mymaster.master" }

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}
```


### Embed Page (.embed)

By using `@[path default]`, we can embed other page files into the page. Normally, require the file with ".embed" suffix, but master and serer page can also be used(not recommend).

So with the given *notice.embed* file :

```html
<h2>
	Here is a description for test page<br/>
	To show how to use embed web pages.
</h2>
```

Re-write the *index.lsp* :

```html
@{ master = "mymaster.master" }

@body{
	@[notice.embed <!-- Notice placeholder -->]
}
```

And the result would be

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<h2>
			Here is a description for test page<br/>
			To show how to use embed web pages.
		</h2>
	</body>
</html>
```

If delete the *notice.embed* file, the output would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<!-- Notice placeholder -->
	</body>
</html>
```

It's also possible to use the inline code in the *path* and *default*, since it would required some parameters, it's better to define it in the helper file - *globalhelper.helper* :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@javascriptInc(name, version, id) {
	<script type="text/javascript">
		@[/js/@appendVerSfx(name, nil, '.js') // /js/@appendVerSfx(name, version, '.js')]
	</script>
}
```

Now, for the *index.lsp* :

```html
@{ master = "mymaster.master" }

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascriptInc("index", 3) }
}
```

If the js file not existed :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript">
			// /js/index.js?v=3
		</script>
	</head>
	<body>

	</body>
</html>
```

If it existed :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript">
			$(function(){
				var _Ver = 1.0;
			})
		</script>
	</head>
	<body>

	</body>
</html>
```

The css files can also be emebed into page files. It's very useful to save the css and js in the page during development, you can easily change the whole behaviors only with several codes in the helper files.

The js and css files are all static files, if they existed as links, those files would be handled by a web server. If they are marked as embed, they'll be loaded into classes, this is done by **System.Web.JavaScriptLoader** and **System.Web.CssLoader**, the two loaders don't use the **System.Web.PageRenderEngine**, so the js and css file's content are written to the reponse directly.


### Inner Request Page

Besides the embed pages, we also could embed the response of other request, like response from a static route handler, or a controller of the MVC framework. Since the request is raised on the server, it's called the inner request, to diff it from the embed pages, we use another style :

```html
@[~path (param, httpmethod)]
```

Like the embed page, the in-line code can be used in the path, the params will be used as the querystring or form based on the http method(default is GET)

Here is an example

```html
@[~/tag/list {id=1}]
```

If the params are only a table, the parentheses can be omit. If the param and httpmethod are all omit, the request of the current page will be send to the inner request, so it'd get the query string or form.


### Lua Code file (.lua)

For one http request, the Lua Server Page's execution will be divided into two steps :

* Call the page object's *OnLoad* method with the http context object, and generate the response header, so if you need validate request's parameters or redirect to other url, you should do it here.

* Call the page object's *Render* method to generate the response body. The *Render* method is generate by the render engine, so you shouldn't care about it.

To define the *OnLoad* method, we can do it within the *index.lsp* by using block code :

```html
@{ master = "mymaster.master" }

@{
	function OnLoad(self, context)
		-- Generate a cookie
		context.Response.Cookies["TestCookie"].Value = "Test"
		context.Response.Cookies["TestCookie"].Expires = System.Date.Now:AddMinutes(10)
	end
}
```

It'd be more clear to split the code and the html template, we can define the code part in a lua file, and then bind it to the *index.lsp*.

Here we define the *index.lua* :

```lua
class "Index" {}

function Index:OnLoad()
	self.PageTitle = "Test Page"

	self.Data = {
		{ Name = "Ann", Age = 12 },
		{ Name = "King", Age = 32 },
		{ Name = "July", Age = 22 },
		{ Name = "Sam", Age = 30 },
	}
end
```

We define the class *Index* in the first line, the class's name should be the same with the file's name(case ignored), we don't give it the super class and other settings because that would be easy to set in the *.lsp* file.

Then give it an *OnLoad* method, in the method, we just init it with *PageTitle* and *Data* values.

Now, we can use *PageTitle* and *Data* in the *index.lsp* :

```html
@{ master="mymaster.master", code="index.lua" }

@title{
	@self.PageTitle
}

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}

@body{
	<table border="1">
		<thead>
			<tr>
				<th>Person Name</th>
				<th>Person Age</th>
			</tr>
		</thead>
		<tbody>
		@> for _, data in ipairs(self.Data) do
			<tr>
				<td style="background-color:cyan">@data.Name</td>
				<td>@data.Age</td>
			</tr>
		@> end
		</tbody>
	</table>
}
```

The *self* is the object created by the page class to handle the http request, you can use it in any web parts, html helpers, inline and full-line codes, it can't be used in local functions unless you pass the self to them.

The output is :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Test Page</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript" src="/js/index.js?v=3"></script>
	</head>
	<body>
		<table border="1">
			<thead>
				<tr>
					<th>Person Name</th>
					<th>Person Age</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td style="background-color:cyan">Ann</td>
					<td>12</td>
				</tr>
				<tr>
					<td style="background-color:cyan">King</td>
					<td>32</td>
				</tr>
				<tr>
					<td style="background-color:cyan">July</td>
					<td>22</td>
				</tr>
				<tr>
					<td style="background-color:cyan">Sam</td>
					<td>30</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
```

Normally we don't need to use the Lua server page and its lua files, the MVC framework is a more better choice.


## MVC框架 - System.Web.MVC

We use the ".view" files as the view, it also use the **PageRenderEngine** so it follow the same rules of the ".lsp" files. Unlike the lua server page, the business code is done in the controllers, not the page class.

We also use the dynamic route to load the controllers, so the first thing is register a route map the url to the controllers:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

main("/user")
```

This is a special route settings, besides the Lua patterns, the route pattern also support a special usage:

* the `{xxxx}` will be used as a capture
* the `{xxxx?}` means the section can match empty string(ignored), the "/" after it will also be ignored
* the `{xxxx|pattern}` the pattern after the "|" will be used to match the string, they are normal Lua patterns
* All captures will be send to the function

The first return value of the function will be used to retrieve the request handler class, and the others values will be used as the init-table for the class to generate the object to handle the request.

Here is some examples:

Url                 |Path                              |Init-table
:-------------------|:---------------------------------|:--------------------
/                   |/controller/homecontroller.lua    |{ Action = "index" }
/user               |/controller/usercontroller.lua    |{ Action = "index" }
/user/profile       |/controller/usercontroller.lua    |{ Action = "profile", ID = 1 }
/topic/list/1       |/controller/topiccontroller.lua   |{ Action = "list", ID = 1 }


### System.Web.Controller

Save the previous code into a file as *test.lua*, and save the below code as *usercontroller.lua* in the same directory of the test file:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	function index(self, context)
		self:Text("This is the home page of user")
	end
end)
```

We don't need to set a module for the file, since it's loaded by the Application "TestWebApp", the file will be processed in the application.

Now you can process the test file, the result should be

```lua
-- This is the home page of user
main("/user")
```

The `__Action__` attribute is used to bind the *Action* to the method, it has two constructors:

Constructor Arguments                                 |Description
:-----------------------------------------------------|:-----------------------------
action: String, method: HttpMethod/HttpMethod.ALL     |Bind the method to the action with the http method
method: HttpMethod/HttpMethod.ALL                     |Use the method name as action, and bind the method to the action with the http method

The **Controller** class has provided several methods to generate the outputs:

Method                  |Arguments                             |Description
:-----------------------|:-------------------------------------|:--------------------------------
Text                    |text: String                          |Send the text as response
Text                    |iter: Functon, ...: Any * 0           |Send the text generated from the iterator as response
View                    |path: String, ...: Any * 0            |Render a page from file with the data as response
Json                    |data: Any, type: AnyType/nil          |Format the data as JSON format and send it as response
Redirect                |path: String, raw: Boolean/false      |Redirect to another url
NotFound                |                                      |Return 404

First let's save the below template as *user.view* in the same directory:

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Hi, I'm @self.name of @self.age years old</p>
	</body>
</html>
```

Then change the *usercontroller.lua* to:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	function index(self, context)
		self:Text("This is the home page of user")
	end

	__Action__()
	function data(self)
		self:Json({ name = "Ann", age = 21 })
	end

	__Action__()
	function view(self)
		self:View("user.view", { name = "Ann", age = 21 })
	end
end)
```

We'll have the result like:

```lua
-- This is the home page of user
main("/user")

-- {"name":"Ann","age":21}
main("/user/data")

-- <html>
--     <head>
--         <title>Ann</title>
--     </head>
--     <body>
--         <p>Hi, I'm Ann of 21 years old</p>
--     </body>
-- </html>
main("/user/view")
```

You can also use the `__View__`, `__Text__`, `__Json__` attribute on them:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	__Text__() function index(self, context)
		return "This is the home page of user"
	end

	__Action__()
	__Json__() function data(self)
		return { name = "Ann", age = 21 }
	end

	__Action__()
	__View__"user.view" function view(self)
		return { name = "Ann", age = 21 }
	end
end)
```

With those attributes, it's very simple to toggle the response format.


## 表单验证

Each http request will bring in the query string or form datas, we need to validate them and convert them to code type values, there is no need to let the developers keep doing this for each request handlers or controller actions.

The `System.Web.__Form__` attribute is used to bind the form validation informations to the handlers or actions, and will finish the validation and conversion, the result will be passed to the handlers or actions.

Let's start with an example, continue use the action test, so you only need to replace the code in the *usercontroller.lua*.

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ {
		name  = { type = String, require = true },
		age   = { type = Number, require = true },
	}
	__Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end
end)
```

The result would be
```lua
-- {"Form":{"name":"ann","age":"2n1"},"Error":{"age":"the %s must be number"}}
main("/user/query", { name = "ann", age = "2n1" })

-- {"Form":{"name":"ann"},"Error":{"age":"the %s can't be nil"}}
main("/user/query", { name = "ann" })
```

For the error messages, you can use `Struct.GetErrorMessage(msg, "age")` to get the error message to be shown on the page.

If you noticed, the `__Form__` will receive a table of the struct type definition, and in it, the table will also be used to create a member struct type used to validate the query string or the form.

It also support complex query structure like :

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ {
		person = struct {
			struct {
				name = String,
				age  = Number,
			}
		}
	}
	__Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end
end)
```

That means the person is a array struct, whose elements is a table with *name* and *age* values. So the test result will be:

```lua
-- {"Form":{"person":[{"name":"Ann","age":21},{"name":"Ben","age":23}]}}
main("/user/query", {
	["person[1].name"] = "Ann",
	["person[1].age"]  = "21",
	["person[2].name"] = "Ben",
	["person[2].age"]  = 23,
})

-- {"Form":{"person":[{"name":"Ann","age":"n"},{"name":1,"age":23}]},"Error":{"person":[{"age":"the %s must be number"},{"name":"the %s must be string, got number"}]}}
main("/user/query", {
	["person[1].name"] = "Ann",
	["person[1].age"]  = "n",
	["person[2].name"] = 1,
	["person[2].age"]  = 23,
})
```

If there is no error, the *err* argument will be nil, so the developers can check it to decide which response should be sent.

You can define custom struct to provide special error message, but keep in mind, if a value must be number, your custom struct must use the **Number** or any struct type based on the **Number** as its base type, so the validation system know that the value should be converted to a number.


## 用户认证

Before process the handlers or actions, we may need to check whether the user is login, or the user has the authority to access the url.

The **PLoop** has provided a `System.Web.__Login__` attribute to simple the task. It'd provide the login validation and the priority checking. You always can create your own features to replace it.


### Login validation

The `__Login__` will check the session if it has a special key saved in the session, if so, the login validation is passed and the process will be turn to the real handlers or actions.

If the key don't existed, the system will redirect the client to the login page with the current url, so when the user login, he will be redirected to the previous url.

There are three settings must be made, the *Key* in the session, the *LoginPage* that where should be redirected to, and the *PathKey* that send to the *LoginPage* with the current url.

The Application has a property `_Config` can be used for configurations(see the 014.configuration for more informations), those can be set like :

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	-- Configuration
	_Config            = {
		Validator      = {
			Key        = "userid",
			LoginPage  = "/user/login",
			PathKey    = "path",
		}
	}

	-- Route
	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)
```

Here is an usage example:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ { person = struct { struct { name = String, age  = Number, } } }
	__Login__() __Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end

	__Action__("login", HttpMethod.GET) __View__"login.view"
	function loginview() end

	__Form__ {
		userid  = { type = String, require = true },
		password= { type = Password, require = true },
		path    = String,
	}
	__Action__("login", HttpMethod.POST) __Redirect__()
	function login(self, context, form, err)
		if err then return "/user/login" end
		context.Session.Items["userid"] = form.userid
		return form.path or "/"
	end
end)
```

If the user is not login, access the `/user/query` will be redirected to `/user/login?path=%2Fuser%2Fquery`

You should set the *Key* to session and redirect to the *Path* in the login page handlers.


### Authority Checking

The priority checking is a little complex, since the system won't know how your authority system is designed.

First you should give parameters to the `__Login__` attribute as the authority requirement for the url.

Then you must add an **AuthorityChecker** function in the `_Config.Validator`, the function will recieve the context and the authority requirement and return two value.

If the first value is true, the user passed the checking, the handler will process the operations, if false, the second value will be used as the redirect path.

Here is an example:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	-- Configuration
	_Config                  = {
		Validator            = {
			Key              = "userid",
			LoginPage        = "/user/login",
			PathKey          = "path",
			AuthorityChecker = function (context, requirement, path)
				if context.Session.Items.level >= requirement then
					return true
				else
					return path or "/user/forbidden"
				end
			end,
		}
	}

	-- Route
	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
```

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ { person = struct { struct { name = String, age  = Number, } } }
	__Login__(4, "/user") __Action__() __Json__()
	function query(self, context, form, err)
		return { Form = form, Error = err }
	end

	__Action__("login", HttpMethod.GET) __View__"login.view"
	function loginview() end

	__Form__ {
		userid  = { type = String, require = true },
		password= { type = Password, require = true },
		path    = String,
	}
	__Action__("login", HttpMethod.POST) __Redirect__()
	function login(self, context, form, err)
		if err then return "/user/login" end
		context.Session.Items["userid"] = form.userid
		context.Session.Items["level"] = 1
		return form.path or "/"
	end

	__Action__()
	__Text__() function forbidden()
		return "You have no right"
	end
end)
```


## 上下文处理器

The process of the request is defined in the **System.Web.IHttpContextHandler**, all context handlers should extend the interface, the **Controller** extend it, the static route functions also will be wrapped as an object that extend the interface.

Here is the features provided by the interface

```lua
--- the http context process phase
__Flags__() __Sealed__()
enum "System.Web.IHttpContextHandler.ProcessPhase" {
	"Init",
	"Head",
	"Body",
	"Final"
}

--- the http context handler's priority
__Sealed__() __Default__(0)
enum "System.Web.IHttpContextHandler.HandlerPriority" {
	Highest                 =  2,
	Higher                  =  1,
	Normal                  =  0,
	Lower                   = -1,
	Lowest                  = -2,
}
```

Abstract Property       |Type                   |Default             |Description
:-----------------------|:----------------------|:-------------------|:--------------------
IsRequestHandler        |Boolean                |false               |Gets or sets whether the handler would check the request is already handled, only for init process phase, if the request is handled and the IsRequestHandler is true, the handler won't be use.
ProcessPhase            |ProcessPhase           |Head + Body         |Gets or sets the handler's process phase
Priority                |HandlerPriority        |Normal              |Gets or sets the handler's priority
AsGlobalHandler         |Boolean                |false               |Gets or sets whether the context handler is used as global handler.
Application             |Application            |                    |Gets or sets the target web application of the global handler
-------------------------------------------------------------------------------------------


Abstract Method         |Arguments                                   |Description
:-----------------------|:-------------------------------------------|:--------------------
Process                 |context: HttpContext, phase: ProcessPhase   |Process the http request
-------------------------------------------------------------------------------------------


Method                  |Arguments                                   |Description
:-----------------------|:-------------------------------------------|:--------------------
RegisterToContext       |context: HttpContext/nil                    |Register self to the context or the current context as temporary handlers

Take the **Route** as example, all routes are managed by the **RouteManager**, each web application has only one route manager, the route manager is a global handler register for the **ProcessPhase.Init** phase, it's a request handler, so it won't be processed when the request is aleady handled.

The global handler means it'll be used for each request, so the route manger will check the request url to find a matched route, if it get one, it'll try get the temp context handler from it, like use the static route handlers directly, or generate a handler from the class generated from the target file. The handler will call its **RegisterToContext** method reigster itself to the context as a temp handler(that's done by the interface itself).

There are three type context handlers.

* Temp handler                   - The static route handlers, the controller, the Lua sever pages are all temp handlers, they are registered to the http context, if the response is sent to the client, the http context will be disposed, so the temp handlers will be released.

* Application Global Handler     - Those handlers are registered as global handler with application, so it'll only works for the http context of the same applications, the route managers are application global handlers.

* Server Global Handler          - Those handlers are registered as global handler without application, it works for all http context created in the server.


Take an example from [NgxLua][], this is used to save the cookies to the reponse, it's server global handler:

```lua
-- the handler to send cookies
IHttpContextHandler {
	ProcessPhase    = IHttpContextHandler.ProcessPhase.Head,
	Priority        = IHttpContextHandler.HandlerPriority.Lowest,
	AsGlobalHandler = true,
	Process = function(self, context, phase)
		if not context.IsInnerRequest then
			local cookies = context.Response.Cookies
			if next(cookies) then
				local cache = {}
				local cnt = 1
				for name, cookie in pairs(cookies) do
					cache[cnt] = tostring(cookie)  -- The http cookie objects can be serialized through __tostring
					cnt = cnt + 1
				end
				ngx.header['Set-Cookie'] = cache
			end
		end
	end,
}
```

The **IHttpContextHandler** has anonymous class, so can be used to generate the handlers directly.

We could use those global handlers to collect informations, like day-access times:

```lua
--- the handler to send cookies
IHttpContextHandler {
	ProcessPhase    = IHttpContextHandler.ProcessPhase.Head,
	Priority        = IHttpContextHandler.HandlerPriority.Lowest,
	AsGlobalHandler = true,
	Application     = app,
	Process = function(self, context, phase)
		if not context.IsInnerRequest then
			with(Redis())(function(redis)
				local count = redis:Execute("INCR", "DAY_ACCESS_COUNT")
				if count == 1 then
					local dt= Date.Now
					redis:SetExpireTime("DAY_ACCESS_COUNT", Date(dt.Year, dt.Month, dt.Day, 23, 59, 59))
				end
			end)
		end
	end,
}
```

This is an application global handlers used to save the access count.

The process of a request is splitted into four phases:

* Init    -- The init phase, used to prepare the context handlers, like register the temp handlers
	* Process the server global handlers
	* Process the application global handlers
* Head    -- The head phase, used to prepare the response head informations
	* Process the temp handlers
	* Process the application global handlers
	* Process the server global handlers
	* Send the headers to the client
* Body    -- The body phase, only processed when the request is not redirected
	* Process the temp handlers
	* Process the application global handlers
	* Process the server global handlers
	* Close the response
* Final   -- The final phase, used to release resources
	* Process the temp handlers
	* Process the application global handlers
	* Process the server global handlers

The handlers will only be processed for its register phases.

It's very interesting in the **Controller**, it's logic is processed over the three phases:

Let's take out the **Text** method as an example:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "This is a test message"

		self:Text(text)

		text = nil
	end
end)
```

We expand the **Text** method, it works like:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "This is a test message"
		print("[PHASE]", context.ProcessPhase)

		local res       = self.Context.Response
		if res.RequestRedirected or res.StatusCode ~= HTTP_STATUS.OK then return end

		res.ContentType = "text/plain"
		coroutine.yield() -- finish head sending

		print("[PHASE]", context.ProcessPhase)

		res.Write(Web.ParseString(text))

		coroutine.yield() -- finish body sending

		print("[PHASE]", context.ProcessPhase)
		text = nil
	end
end)
```

The result would be

```lua
-- [PHASE]    2
-- [PHASE]    4
-- [PHASE]    8
-- This is a test message
main("/user/query")
```

So after the `self:Text(text)`, it's very safe to release resouces or finish other tasks, it won't block other requests.


## 错误处理

The web system would track the errors during the process, it also will track the errors of the template system which is more hard to debug.

But first, we need give it an error handler, it's also a configuration :

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", System.Web.IHttpContextHandler.ProcessPhase }

	_Config = {
		ErrorHandler            = function(err, stack, context)
			if context.ProcessPhase == ProcessPhase.Final then
				error(err, stack)
			else
				context:ProcessInnerRequest("/error", { error = err })
				context.Response:Close()
			end
		end,
	}

	__Route__ "/error"
	__View__ "error.view" [[
		<html>
			<head>
				<title>Error</title>
			</head>
			<body>
				<p>@self.error</p>
			</body>
		</html>
	]]
	function errorhandler(context)
		return { error = context.Request.QueryString.error }
	end

	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

main("/user/query")
```

We give an **ErrorHandler** to the `_Config`, it'll receive error, stack and context, we checked the `context.ProcessPhase`, since we can't send the response when it's already done, then we pass the error to the `/error` url.

Let's modify the *usercontroller.lua* and see the result:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "hello" .. context.Request.QueryString.name
		self:Text(text)
	end
end)
```

```html
<html>
	<head>
		<title>Error</title>
	</head>
	<body>
		<p>xxxxx/usercontroller.lua:5: attempt to concatenate a nil value (field 'name')</p>
	</body>
</html>
```

Then let's modify the *user.view* and *usercontroller.lua*:

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Score: @(self.data > 60 and "Pass" or "Failed")</p>
	</body>
</html>
```

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		self:View("user.view", { name = "Ann", data = nil })
	end
end)
```

We'll get the result:

```html
<html>
	<head>
		<title>Ann</title>
	</head>
	<body>
		<p>Score: 		<html>
			<head>
				<title>Error</title>
			</head>
			<body>
				<p>xxxxxx/user.view:6:  attempt to compare number with nil</p>
			</body>
		</html>
```

Well, it's a little odd, since the response is sent as stream, we may need see the source of the page to find out the error messages.


## 相对路径和绝对路径

In the above examples, we use paths for master, helper, code, view and etc. Here are some details about the path :

* The root path can be get by HttpRequest.Root.

* Path started with "/" is an absolute path, combine the root path and the absolute path is the target file's path.

* Path not started with "/" is a relative path, combine current file's directory and the relative path is the target file's path. So if we have a controller '/controller/usercontroller.lua', it use a view 'view/profile.view', the view's absolute path should be '/controller/view/profile.view', you can also use `..` for the parent directory.



## 视图的配置

The template system also registered the configurations to the **System.Web.Config.View** and the web application's `_Config.View`.

Here is an example:

```lua
_Config = {
	View                    = {
		Default             = {
			master          = nil,
			helper          = nil,
			reload          = false,
			encode          = true,
			noindent        = true,
			nolinebreak     = true,
			linebreak       = "\n",
			engine          = nil, -- default System.Web.PageRenderEngine
			asinterface     = nil,
			export          = {
				error       = function(message, target)
					return Struct.GetErrorMessage(message, target)
				end,
			},
		},

		ViewPage             = {
			reload           = true,
		},
	},
}
```

The *View* contains all settings for each type template files:

Name             |Super                 |suffix                |Description
:----------------|:---------------------|:---------------------|:--------------------------------
Default          |                      |.*                    |For all template files
HtmlPage         |Default               |.*                    |For all html page files
StaticFile       |Default               |.*                    |For all static files
ViewPage         |HtmlPage              |.view                 |For view files
EmbedPage        |HtmlPage              |.embed                |For embed page files
PageHelper       |HtmlPage              |.helper               |For helper files
LuaServerPage    |HtmlPage              |.lsp                  |For the lua server page files
MasterPage       |HtmlPage              |.master               |For the master page files
CssFile          |StaticFile            |.css                  |For css files that used as resources
JavascriptFile   |StaticFile            |.js                   |For js files that used as resources

The settings will use its super's settings if it don't have one.

For those sub configurations:

Name           |Type                          |Description
:--------------|:-----------------------------|:-------------------------------
master         |String                        |The master page for all the type files
helper         |String                        |The helper page for all the type files
reload         |Boolean                       |Set all the type files whether reload when modified
encode         |Boolean                       |Set all the type files whether encode every expression
noindent       |Boolean                       |Set all the type files whether don't output indents
nolinebreak    |Boolean                       |Set all the type files whether don't output line break
linebreak      |String                        |Set the linkbreak to all the type files
engine         |- System.Web.IRenderEngine    |Set the render engine to the type files, normally don't set it
asinterface    |Boolean                       |Set all the type files whether the returned type should be an interface
export         |Table                         |A table whose items will be exported to the environment where the resource is generated, so it can use all variables defined in the table

The configuration in the resource file's head line will override the settings provided here.

Normally only *noindent*, *nolinebreak* and *export* are need.

With the previous settings, a view like :

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Score: @(math.random(100) > 60 and "Pass" or "Failed")</p>
	</body>
</html>
```

The result would be :

```html
<html><head><title>Ann</title></head><body><p>Score: Pass</p></body></html>
```

So you can reduce the reponse length just by two settings, you can apply those configuration on the application or on the **Web** for all applications.


## 自定义渲染引擎

The **PLoop** only provied two render engine : **System.Web.PageRenderEngine** used to support a template system like the Razor for Asp.Net, and the **System.Web.StaticFileLoader** used for static files like the css.

Now, we'll see how to create the custom render engines, this is based on the text analysis.

The render engine must extend the **System.Web.IRenderEngine** and provide several methods:

Abstract Method    |Arguments                                        |Description
:------------------|:------------------------------------------------|:-------------------------
Init               |loader: IOutputLoader, config: RenderConfig      |Init the engine with the page loader and the page config
ParseLines         |reader: TextReader                               |Parse the lines and yield all content with type

The **ParseLines** will be called within an iterator, the **IRenderEngine** has extend the **Iterable** interface.

For the static files, the **ParseLines** is defined like :

```lua
function ParseLines(self, reader)
	-- Use yield not return to send back content and other informations

	-- The Render is the start method of the whole page rendering
	-- the system don't care the name of other methods, but this must be
	-- provided by all page classes(or its master page class)
	coroutine.yield(RenderContentType.MixMethodStart, "Render")

	for line in reader:ReadLines() do
		line = line:gsub("%s+$", "")
		coroutine.yield(RenderContentType.RecordLine, line)

		coroutine.yield(RenderContentType.StaticText, line)

		coroutine.yield(RenderContentType.NewLine)
	end

	coroutine.yield(RenderContentType.MixMethodEnd)
end
```

Here is the explains:

* We use the coroutine to yield all the op codes and data to make sure we can track the context of analysis.
* We yield the op code defined in the **RenderContentType**, so the system know how to use it to generate the page classes.
* The **RenderContentType.RecordLine** will be used to map the code line with the template line, so the system know where the bug comes from, it's very important.

Here are the op codes from the **RenderContentType**:

Name               |Parameters                                                       |Description
:------------------|:----------------------------------------------------------------|:------------------------------------
RecordLine         |line:String                                                      |record the line with an auto-incr line number for error location
StaticText         |text:String                                                      |the static text
NewLine            |                                                                 |write a new line
LuaCode            |line:String                                                      |the lua code line like `if xxx then`
Expression         |exp:String                                                       |the expression to be executed and write the result
EncodeExpression   |exp:String                                                       |the expression to be executed and the result must be encoded then sent out
MixMethodStart     |name:String                                                      |start the creation of a mix method, the mix method is also the object method of the generated the class
MixMethodEnd       |                                                                 |end the creation of the previous mix method
CallMixMethod      |name:String, params:String, default:String, issupercall:Boolean  |call a mix method with params, if not existed, use the default, if issupercall, then the super class's mix method will the name will be used, like the usage of the `@{super:body}`
RenderOther        |path:String, params:String, default:String                       |Render other files, like the embed pages
InnerRequest       |url:String, params:String                                        |Render with an inner request call


So with those codes, we can change a template file into the definition of the page class.

Now we have a **index.wf** template:

```html
html
	head
		title
			> my web site
	body
		div #mainDiv .center
			p #random style='width:100px'
				> random is {{ math.random(10000) }} pts
```

We'll create a custom engine and register a resource loader based on the engine for it:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"
require "PLoop.System.IO"

PLoop(function(_ENV)
	import "System.IO.Resource"
	import "System.Web"

	-- Define the render engine
	class "WaterFallEngine"(function (_ENV)
		extend "IRenderEngine"

		local yield 	= coroutine.yield

		local NOT_CHILD = 0
		local NODE_ELE 	= 1
		local TEXT_ELE 	= 2

		local function parseLine(self, reader, chkSpace, isFirstChild)
			line = self.CurrentLine or reader:ReadLine()

			self.CurrentLine = nil

			if not line then return NOT_CHILD end
			line = line:gsub("%s+$", "")

			local space, tag, ct = line:match("^(%s*)(%S+)%s*(.*)$")

			space = space or ""

			if tag == ">" then
				-- It's a text element
				-- for "random is {{ math.random(10000) }} pts"

				local startp = 1
				local expSt, expEd = ct:find("{{.-}}", startp)

				while expSt do
					-- "random is " is static text
					yield(RenderContentType.StaticText, ct:sub(startp, expSt - 1))

					-- math.random(10000) is an expression
					yield(RenderContentType.Expression, ct:sub(expSt + 2, expEd - 2))

					startp = expEd + 1
					expSt, expEd = ct:find("{{.-}}", startp)
				end

				-- The remain " pts" is also static text
				yield(RenderContentType.StaticText, ct:sub(startp))

				return TEXT_ELE
			end

			-- Check if it's a child node
			if not chkSpace or #space > #chkSpace then
				-- This is a node
				-- for "		div #mainDiv .center"

				-- If the node is a child node, we need add a new line
				if chkSpace then
					if isFirstChild then
						yield(RenderContentType.NewLine)
					end

					-- "		" space is static text, don't forget it
					yield(RenderContentType.StaticText, space)
				end

				-- Get id, class and other settings
				local id, cls = "", ""
				local cache = { tag }

				-- Get and remove id from ct
				ct = ct:gsub("#(%w+)", function(w) id = w return "" end)
				if #id > 0 then
					table.insert(cache, ([[id="%s" name="%s"]]):format(id, id) )
				end

				-- Get and remove class from ct
				ct = ct:gsub("%.(%w+)", function(w) cls = cls .. w .. "," return "" end)
				if #cls > 0 then
					table.insert(cache, ([[class="%s"]]):format(cls:sub(1, -2)) )
				end

				-- Get the remain
				ct = ct:gsub("^%s*(.-)%s*$", "%1")
				if ct and #ct > 0 then
					table.insert(cache, ct)
				end

				-- "div #mainDiv .center" -> StaticText: <div id="mainDiv" name="mainDiv" class="center">
				yield(RenderContentType.StaticText, "<" .. table.concat(cache, " ") .. ">")

				-- check the next line
				local firstNode = true

				while true do
					local ret = parseLine(self, reader, space, firstNode)

					firstNode = false

					if ret == TEXT_ELE then
						-- Close the tag
						yield(RenderContentType.StaticText, "</" .. tag .. ">")

						-- Generate a new line
						yield(RenderContentType.NewLine)

						return NODE_ELE
					elseif ret == NODE_ELE then
						-- We have a child node, just keep parsing
					else
						-- we meet the end of the node
						if #space > 0 then
							yield(RenderContentType.StaticText, space)
						end

						-- Close the tag
						yield(RenderContentType.StaticText, "</" .. tag .. ">")

						-- Generate a new line
						yield(RenderContentType.NewLine)

						return NODE_ELE
					end
				end
			else
				-- This is not a child node, so return to close the previous node
				self.CurrentLine = line

				return NOT_CHILD
			end
		end

		function ParseLines(self, reader)
			yield(RenderContentType.MixMethodStart, "Render")

			parseLine(self, reader)

			-- end
			yield(RenderContentType.MixMethodEnd)
		end
	end)

	__ResourceLoader__"wf"   -- Register for the .wf files
	__PageRender__("WaterFallPage", IOutputLoader, { engine = WaterFallEngine })  -- Bind the render engine
	class "System.Web.WaterFallPage" { IOutputLoader }
end)

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", System.Web.IHttpContextHandler.ProcessPhase }

	_Config = {
		View                = {
			Temporary       = "/temp",
		},
	}

	__Route__ "/index"
	__View__ "/index.wf"
	function index(context)
		return { name = "Ann" }
	end
end)

-- The test code to simulate the http request
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

-- <html>
--     <head>
--         <title>Ann web site</title>
--     </head>
--     <body>
--         <div id="mainDiv" name="mainDiv" class="center">
--             <p id="random" name="random" style='width:100px'>random is 4150 pts</p>
--         </div>
--     </body>
-- </html>
main("/index")
```

In the *app*, we declare a Temporary path `/temp`, the page class's definition will be saved into the target folder for debug if given, here is the generated code for the *index.wf*:

```lua
local _PL_HtmlEncode, tostring = System.Web.HtmlEncode, System.Web.ParseString
function Render(self, _PL_write, _PL_indent)
	_PL_indent = _PL_indent or ""
	_PL_write(_PL_indent)
	_PL_write("<html>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("<head>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("		")
	_PL_write("<title>")
	_PL_write(tostring( self.name ))
	_PL_write(" web site")
	_PL_write("</title>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("</head>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("<body>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("		")
	_PL_write("<div id=\"mainDiv\" name=\"mainDiv\" class=\"center\">")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("			")
	_PL_write("<p id=\"random\" name=\"random\" style='width:100px'>")
	_PL_write("random is ")
	_PL_write(tostring( math.random(10000) ))
	_PL_write(" pts")
	_PL_write("</p>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("		")
	_PL_write("</div>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("	")
	_PL_write("</body>")
	_PL_write("\n")
	_PL_write(_PL_indent)
	_PL_write("</html>")
end
```

It's useful when test the custom page render engines.


[PLoop.Browser]: https://github.com/kurapica/PLoop.Browser  "PLoop Lib Browser"
[nginx]: https://www.nginx.com/ "Nginx"
[Openresty]: https://github.com/openresty/lua-nginx-module/ "Openresty"
[NgxLua]: https://github.com/kurapica/NgxLua/ "An implementation for the Openresty"