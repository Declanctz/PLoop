# System.Web

**System.Web** is a web framework designed to be an abstract layer for web development, it'd provide interfaces and features that not depends on the web server.

The System only support UTF-8 for now.

This is an abstract framework so can't be used in any web server directly, You can find runnable example [PLoop.Browser][], it used an implementation [NgxLua][] which is designed for the [Openresty][].


## System.Web.Application

An **Application** is a standalone web service, a server like *nginx* can host several applications. The application will have its own configurations, routers, controllers and etc.

Here is a simple web application:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop"
require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	__Route__("/jsonhandler", HttpMethod.GET)
	__Json__() function JsonHandler(context)
		return {
			Data = {
				{ Name = "Ann", Age =  12},
				{ Name = "King", Age =  32},
				{ Name = "July", Age =  22},
				{ Name = "Sam", Age =  30},
			}
		}
	end
end)
```

Before loading the **PLoop**, we must set the **MULTI_OS_THREAD** to true, since web service like the [Openresty][] is a multi-os thread platform.

The **Application** is inheirted from the **System.Module**, so normally it works like the module system.

In the app, we have a *JsonHandler* function who has two attribute:

* `__Route__("/jsonhandler", HttpMethod.GET)` register the function as the handler for route `/jsonhandler` when the http method is "GET"
* `__Json__` means the return value of the function will be serialized to JSON format and send to the response.

Now we can simulate the process of the http request and get a result from the web app:

```lua
-- Copy the previous example code here

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

    ctx.Request = HttpRequest(ctx)
    ctx.Request.HttpMethod = method
    ctx.Request.Root = IO.Path.CombinePath(IO.Path.GetCurrentPath(), "root")
    ctx.Request.Url = url

    if method == HttpMethod.GET then
	    ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

    ctx.Response = HttpResponse(ctx)
    ctx.Response.Write = function(str) writer:Write(str) end
    ctx:Process()
    writer:Close()
    print(writer.Result)
end

-- {"Data":[{"Name":"Ann","Age":12},{"Name":"King","Age":32},{"Name":"July","Age":22},{"Name":"Sam","Age":30}]}
main("/jsonhandler")
```

In the main function, we create the **HttpContext** of the web app and then we create the **HttpRequest** and **HttpResponse** of the context.

After those objects created, we can call the **Process** method of the context, the context will check the web app's router system to find a match handler to url, and then use the handler to process the request and send the result to the response.

In a real project, the request, response is generated by the system, you don't need to manually do it.

For those handlers defined in the application, they are the static route handlers.


### `System.Web.__Json__`

As we can see the `__Json__` attribute will wrap the function and use it as the route handler, the return value of the function should be serialized to JSON format data.

The funciton will receive the http context object, so we can get the query string or form from the request:

```lua
__Route__("/jsonhandler", HttpMethod.GET)
__Json__() function JsonHandler(context)
	return {
		User = { Name = context.Request.QueryString.name }
	}
end

-- {"User":{"Name":"ann"}}
main("/jsonhandler", {name = "ann"})
```

The other codes are skipped, you can test it by your own.


### `System.Web.__Text__`

The `__Text__` attribute is used to generate the text as response, it can only return a text or be used as an iterator to generate the texts:

```lua
__Route__("/text", HttpMethod.GET)
__Text__() function TextHandler(context)
	return "Hello, this is single text test"
end

__Route__("/multitext", HttpMethod.GET)
__Text__(true) __Iterator__()
function MultiText(context)
	coroutine.yield("This is part of the result\n")
	coroutine.yield("This is another part of the result\n")
end

-- Hello, this is single text test
main("/text")

-- This is part of the result
-- This is another part of the result
main("/multitext")
```

The `__Text__(true)` means the function is async, should be used as an iterator.


### `System.Web.__Redirect__`

The `__Redirect__` attribute is used to redirect the client to a new url, the function should return the new url.

```lua
__Route__("/redirect")
__Redirect__() function TextHandler(context)
	return context.Request.QueryString.path or "/404"
end
```


### `System.Web.__View__`

The `__View__` attribute is used to bind a view template or template file path to the target function, so the return value of the function will be used to generate the output response:

```lua
__Route__("/index")
__View__ "index.view" [[
	<html>
		<head>
			<title>@self.title</title>
		</head>
		<body>
			<p>@self.welcome</p>
		</body>
	</html>
]]
function index(context)
	local name = context.Request.QueryString.name

	return { title = "Hi " .. name, welcome = "Welcome here, " .. name }
end


-- <html>
--    <head>
--        <title>Hi Ann</title>
--    </head>
--    <body>
--        <p>Welcome here, Ann</p>
--    </body>
-- </html>
main("/index", { name = "Ann" })
```

The `index.view` has two usage, the `index` will be used to generate as the view class name, and the `.view` will notify the system to use the registered **ResourceLoader** to load the text to a view class. Then the view class would be used to generate the output.

For the snippet `@self.title` in the template, the self is a view class's object, it'd use the return value from the function as the object's init-table.

Normally the view is used in the MVC framework, we'll see more details about the template system at later.


## System.Web.HttpContext


[PLoop.Browser]: https://github.com/kurapica/PLoop.Browser  "PLoop Lib Browser"
[nginx]: https://www.nginx.com/ "Nginx"
[Openresty]: https://github.com/openresty/lua-nginx-module/ "Openresty"
[NgxLua]: https://github.com/kurapica/NgxLua/ "An implementation for the Openresty"